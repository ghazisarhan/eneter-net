<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework.Phone</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            Functionality to work with the Broker.
            </summary>
            <remarks>
            The broker is intended for publish-subscribe scenarios. Clients can use the broker to subscribe for messages and also for sending of
            notification messages.<br/>
            The broker works like this:<br/>
            The client has some event that wants to notify to everybody who is interested. Therefore, the client sends the message to the broker.
            The broker receives the message and forwards it to everybody who is subscribed for such event.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            The interface declares the broker.
            The broker receives messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            The interface declares methods to attach/detach one IDuplexInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachedDuplexInputChannel">
            <summary>
            Retutns attached duplex input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via Http.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.SentMessageItem">
            <summary>
            Represents the message that was sent.
            It stores the message id and the time when the message was sent.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel">
            <summary>
            Declares the reliable duplex input channel.
            </summary>
            <remarks>
            It behaves like <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/> and can also be used everywhere where <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>
            is required.<br/>
            In addition, the reliable duplex input channel provides events <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered"/> and
            <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered"/>.
            The method <see cref="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.SendResponseMessage(System.String,System.Object)"/> returns unique id of the sent message.
            <br/><br/>
            The reliable duplex input channel can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            It cannot receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            Declares the duplex input channel that can receive messages from the duplex output channel and send back response messages.
            </summary>
            <remarks>
            Notice, the duplex input channel works only with duplex output channel and not with output channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the connected IDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId">Identifies the response receiver. The identifier comes with received messages.</param>
            <param name="message">response message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the response receiver.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex output channel closed the connection.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns id of this duplex input channel.
            The id represents the 'address' the duplex input channel is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel">
            <summary>
            The interface declares the composit duplex input channel.
            The composit duplex input channel is the duplex input channel that uses underlying duplex input channel
            to receive messages and send respones messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel.UnderlyingDuplexInputChannel">
            <summary>
            Returns the underlying duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message.
            </summary>
            <param name="responseReceiverId">identifies the receiver of the response message</param>
            <param name="message">message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered to the reliable duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered">
            <summary>
            The event is invoked if the response message was not delivered until the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender">
            <summary>
            The interface declares the string message sender.
            The sender is able to send text messages via one-way output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel">
            <summary>
            The interface declares the API to attach/detach one IOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.AttachOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel)">
            <summary>
            Attaches the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.DetachOutputChannel">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.IsOutputChannelAttached">
            <summary>
            Returns true if the output channel is attached.
            </summary>
            <remarks>
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.AttachedOutputChannel">
            <summary>
            Returns attached output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the string message via the attached output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandContext`2">
            <summary>
            The interface represents the context of the particular command execution.
            It is passed as the input parameter to the method performing the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until the input data fragment is received.<br/>
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <returns>data fragment wrapping the input data</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData(System.Int32)">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until
            the input data fragment is received or the specified timeout occured.
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time for the input data. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>data fragment wrapping the input data</returns>
            <exception cref="T:System.TimeoutException">when the maximum waiting time for the input data is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause">
            <summary>
            If the pause is the current request then it blocks the calling thread until resumed or canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause(System.Int32)">
            <summary>
            If the pause is requested then it blocks the calling thread until resumed or canceled.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time in miliseconds</param>
            <returns>true if the timeout did not occur</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponsePause">
            <summary>
            Notifies the command proxy that the command was paused.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseCancel">
            <summary>
            Notifies the command proxy that the command was canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseFailure(System.String)">
            <summary>
            Notifies the command proxy that the command failed.
            </summary>
            <param name="errorMessage">error message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0)">
            <summary>
            Sends the return data to the command proxy.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean)">
            <summary>
            Sends the return data to the command proxy.
            The method can be used if the return data is sent in more fragments.
            E.g. If the command wants to notify progress or some partial results.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <param name="sequenceId">identifies the sequence where the fragment of return data belongs</param>
            <param name="isReturnDataSequenceCompleted">true if this is the last fragment of the sequence</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandProxyId">
            <summary>
            Returns identifier of the command proxy that executed this command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandId">
            <summary>
            Returns identifier of this command. (If one command proxy executes more commands they can be recognized with this id.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.NumberOfInputData">
            <summary>
            Returns number of input data in the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CurrentRequest">
            <summary>
            The currently set request for the command e.g. Pause, Resume or Cancel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.IsCommandProxyConnected">
            <summary>
            Returns true if the command proxy that executed the command is still connected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for serialization and deserialiazation of data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            The interface declares the API for serialization and deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data to object.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.MultiInstanceFragmentProcessor">
            <summary>
            Implements the fragment processor able to process more sequences of fragments in parallel.
            It creates the fragment processor (IFragmentProcessor) for each sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor">
            <summary>
            The interface declares the fragment processor that is able to process more sequences in parallel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            Declares the factory to create the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel">
            <summary>
            Declares the input channel that can receive messages from the output channel.
            </summary>
            <remarks>
            Notice, the input channel can receive messages only from the output channel.
            It cannot receive messages from the duplex output channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StartListening">
            <summary>
            Starts listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StopListening">
            <summary>
            Stops listening.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.ChannelId">
            <summary>
            Returns id of the channel.
            The channel id represents the address the receiver is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening">
            <summary>
            Returns true if the input channel is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage">
            <summary>
            The message internally used for the reliable communication between reliable duplex output channel
            and reliable duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor">
            <summary>
            Default constructor for serializing purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor(System.String)">
            <summary>
            Constructs the acknowledge message.
            Acknowledge confirms, the message was delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the reliable message that contains the message to be sent.
            </summary>
            <param name="messageId"></param>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.MessageId">
            <summary>
            In case of the message type Message - unique id of the reliable message.
            In case of the message type Acknowledge - id of the message, that is acknowledged.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.Message">
            <summary>
            In case of the message type Message - the message that shall be sent reliably.
            In case of the message type Acknowledge - not used.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType">
            <summary>
            Indicates the purpose of the message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType.Message">
            <summary>
            The reliable message contains a message that shall be notified via the event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessage.EMessageType.Acknowledge">
            <summary>
            The reliable message is the acknowledgement, that the message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1">
            <summary>
            The message fragment for the specified message type.
            The message fragment wrapps the specified message type so that it can be sent as a part of a sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.Fragment">
            <summary>
            Provides the basic implementation for IFragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragment">
            <summary>
            The interface declares the fragment.
            Fragments are used to sequence data.
            The fragment contains the SequenceId identifying the sequence where the fragment blongs, Index specifying the position in the sequence
            and IsFinal indicating if it is the last fragment of the sequence.<br/>
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.SequenceId">
            <summary>
            Returns identifier of the sequence where the fragment belongs.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.IsFinal">
            <summary>
            Returns true if it is the last fragment in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from the input parameters.
            </summary>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Position in the sequence.</param>
            <param name="isFinal">Indicates whether it is the last fragment.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.IsFinal">
            <summary>
            Returns true if the item is the last in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed duplex message sender.
            The duplex sender is able to send messages of the specified type and receive responses of the specified type.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            The interface declares the API to attach/detach one IDuplexOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel and opens the connection for listening to response messages.
            </summary>
            <param name="duplexOutputChannel">Duplex output channel to be attached.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the reference to the duplex output channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the value 'true' does not mean the connection is open. If the duplex output
            channel was successfuly attached but the connection was broken, the channel stays attached but the connection is not open.
            To detect if the attached channel is listening to response messages, check the property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachedDuplexOutputChannel">
            <summary>
            Returns attached duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the strongly typed message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed duplex message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message back to the duplex typed message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex typed message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message from a duplex typed message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory">
            <summary>
            Implements the factory to create reliable string message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory">
            <summary>
            The interface declares the factory to create reliable string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory.CreateReliableDuplexStringMessageSender">
            <summary>
            Creates the reliable string message sender.
            </summary>
            <returns>reliable string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessagesFactory.CreateReliableDuplexStringMessageReceiver">
            <summary>
            Creates the reliable string message receiver.
            </summary>
            <returns>reliable string message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory.CreateReliableDuplexStringMessageSender">
            <summary>
            Creates the reliable string message sender.
            </summary>
            <returns>reliable string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.ReliableStringMessagesFactory.CreateReliableDuplexStringMessageReceiver">
            <summary>
            Creates the reliable string message receiver.
            </summary>
            <returns>reliable string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.NamespaceDoc">
            <summary>
            The namespace contains functionality to send commands and receive responses.
            The command allows to execute, pause, resume or cancel some activity on the receiver side.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2">
            <summary>
            The interface declares the reliable command proxy.
            The command proxy is able to send the request to execute some activity in the respective command.
            The command proxy is also able to request pause, resume or cancel.
            It receive response messages from the command.
            In addition, the reliable command proxy notifies whether the request message was delivered.
            The reliable command proxy can be used only with the reliable command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel">
            <summary>
            The interface declares methods to attach/detach IReliableOutputChannel
            </summary>
            <remarks>
            For more details about the reliable output channel see <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.AttachReliableOutputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel)">
            <summary>
            Attaches the reliable output channel and starts listening to response messages.
            </summary>
            <param name="reliableOutputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.DetachReliableOutputChannel">
            <summary>
            Detaches the reliable output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.IsReliableOutputChannelAttached">
            <summary>
            Returns true if the reliable output channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableOutputChannel.AttachedReliableOutputChannel">
            <summary>
            Returns attached reliable output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Pause(System.String)">
            <summary>
            Sends the pause request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Resume(System.String)">
            <summary>
            Sends the resume request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Cancel(System.String)">
            <summary>
            Sends the cancel request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String,`1)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.Execute(System.String,`1,System.String,System.Boolean)">
            <summary>
            Sends the execute request to the command.
            The input data is sent as a sequence.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
            <param name="sequenceId">input data sequence identifier</param>
            <param name="isSequenceCompleted">true - if the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.CommandResponseReceived">
            <summary>
            The event is invoked when the response message from the command was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommandProxy`2.MessageNotDelivered">
            <summary>
            The message is invoked if the message was not delivered until specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy">
            <summary>
            Lists possibilities how the command will process requests for execution.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.SingleThread">
            <summary>
            All requests to execute the command are queued and processed by one thread.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.MultiThread">
            <summary>
            All requests to execute the command are executed immediately in separate threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandInputData`1">
            <summary>
            The class is used by the eneter framework to transfer a request to the command.
            </summary>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor">
            <summary>
            Default constructor for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandRequest,`0)">
            <summary>
            Constructs from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="request">type of the request</param>
            <param name="inputData">input data</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.InputData">
            <summary>
            Input data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Adds the data to already serialized data.
            </summary>
            <remarks>
            It creates the <see cref="T:Eneter.Messaging.DataProcessing.Wrapping.WrappedData"/> from the given data and serializes it with the provided serializer.<br/>
            </remarks>
            <param name="addedData">Added data. It must a basic .Net type. Otherwise the serialization will fail.</param>
            <param name="originalData">Already serialized data - it is type of string or byte[].</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
            <returns>deserialized WrappedData</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            Functionality for writing and reading messages from a stream.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Output bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages synchronously in the context of the caller thread.
            </summary>
            <remarks>
            This messaging system transfers messages synchronously in the context of the calling thread.
            Therefore the calling thread is blocked until the message is delivered and processed.
            However, the notification events (e.g. connection opened, ...) can come in a different thread.
            The messaging system is very fast and is suitable to deliver messages locally between internal communication components.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId">
            <summary>
            Represents the message that contains the sender id too.
            It is used for request-response messaging where the sender id is used by the message
            receiver to send back the response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId.SenderId">
            <summary>
            Id of the message sender. The message receiver can use the sender id to send back the response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId.Message">
            <summary>
            The content of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via HTTP.
            </summary>
            <remarks>
            It creates the communication channels using HTTP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: http://127.0.0.1/something/ or https://127.0.0.1/something/. <br/>
            Because HTTP is request-response based protocol, it does not keep the connection open.
            Therefore, for the bidirectional communication used by duplex channels, the polling mechanism is used.
            The duplex output channel regularly polls for response messages and the duplex input channel constantly measures the inactivity time
            to recognize whether the duplex output channel is still connected.<br/><br/>
            Notice, to start listening via input channel (or duplex input channel), the application must be executed with sufficient rights.
            Otherwise the exception will be thrown.<br/>
            Also notice, Silverlight and Windows Phone 7 do not support listening to HTTP requests.
            Therefore, only sending of messages (and receiving response messages) is possible in these platforms.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            Declares the factory that creates communication channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">identifies the receiving input channel</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The input channel listens on the address specified by the channel id.<br/>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">identifies the address, the input channel listens to</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">unique identifier of the response receiver represented by this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">identifies the address, the duplex input channel listens to</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channels with default settings. The polling
            frequency will be 500 ms and the inactivity timeout will be 10 minutes.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            <br/><br/>
            In case of Silverlight or Windows Phone 7, the response messages are recieved in the main Silverlight thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            The response messages are received in the main silverlight thread.
            </summary>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="receiveInSilverlightThread">true if the response messages shall be received in the main silverlight thread</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel by using HTTP.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel. The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/ </param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving message from the output channel using Http.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/ .
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">valid URI address, the input channel will listen to</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myPollingFrequency">
            <summary>
            Defines how often the client poll the server for response messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory">
            <summary>
            Implements the messaging factory extending the underlying messaging system by monitoring the connection
            between duplex output channel and duplex input channel.
            </summary>
            <remarks>
            When the connection is monitored, the duplex output channel periodically sends 'ping' messages
            to the duplex input channel and waits for responses.
            If the response comes within the specified timeout, the connection is open.
            <br/>
            On the receiver side, the duplex input channel waits for the 'ping' messages and monitors if the connected
            duplex output channel is still alive. If the 'ping' message does not come within the specified timeout,
            the particular duplex output channel is disconnected.
            <br/><br/>
            Notice, the output channel and the input channel do not maintain an open connection.
            Therefore, the monitored messaging is not applicable for them. The implementation of this factory just uses
            the underlying messaging to create them.
            <br/><br/>
            <b>Note</b>
            Channels created by monitored messaging factory cannot communicate with channels, that were not created
            by monitored factory. E.g. the channel created with the monitored messaging factory with underlying TCP
            will not communicate with channels created directly with TCP messaging factory. The reason is, the
            communicating channels must understand the 'ping' communication.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory from specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize 'ping' messages</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            Since the output channel communicates oneway and does not maintain the open connection,
            the monitoring of the connection is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel communicates oneway and does not maintain the open connection,
            the monitoring of the connection is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of the channel</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            It also checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            timeout, the duplex output channel is disconnected. The event <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/>
            is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel">
            <summary>
            Declares the output channel that can send messages to the input channel.
            </summary>
            <remarks>
            Notice, the output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <param name="message">serialized message</param>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.ChannelId">
            <summary>
            Returns the id representing the address where messages are sent.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel">
            <summary>
            The interface declares the composit output channel.
            The composit output channel is the output channel that uses underlying output channel
            to send messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel.UnderlyingOutputChannel">
            <summary>
            Returns the underlying output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2">
            <summary>
            The interface declares the duplex receiver for sequence of typed messages.
            The receiver is able to receive sequence of messages of specified type and response the sequence of messages
            of specified type. <br/>
            It is guaranteed the sequence is received in the same order as was sent. <br/>
            <b>Note: Be aware that if the 'thread pool messaging system' is chosen the incoming messages
            are processed in more threads in parallel. Therefore the 'thread pool messaging system'
            cannot guarantee the order of incoming messages. <br/>
            Consider to use the 'thread messaging system' instead.
            </b>
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of the receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.SendResponseMessage(System.String,`0,System.String,System.Boolean)">
            <summary>
            Sends the response message to the specified duplex typed sequenced message sender.
            </summary>
            <param name="responseReceiverId">specifies the duplex typed sequenced message sender that will receive the response</param>
            <param name="responseMessage">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender closed the connection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory">
            <summary>
            Implements the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory">
            <summary>
            The interface declares the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor">
            <summary>
            Constructs the typed messages factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b> 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel">
            <summary>
            The interface declares the API to attach/detach one IInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.AttachInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel)">
            <summary>
            Attaches the input channel.
            It stores the reference to the input channel and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.DetachInputChannel">
            <summary>
            Detaches the input channel.
            It cleans the reference to the input channel and stops the listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.IsInputChannelAttached">
            <summary>
            Returns true if the reference to the input channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the true value does not mean the channel is listening.
            The method AttachInputChannel() starts also the listening, but if the listening stops (for whatever reason),
            the input channel stays attached. To figure out if the input channel is listening use property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.AttachedInputChannel">
            <summary>
            Returns attached input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver">
            <summary>
            The interface declares the string message receiver.
            The receiver is able to receive text messages via one-way input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver.MessageReceived">
            <summary>
            The event is invoked when a string message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs">
            <summary>
            Event data when an error was detected during receiving a request in the command.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs">
            <summary>
            Event data when a request was received in the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="commandId">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandProxyId">
            <summary>
            Gets the identifier of the command proxy that sent the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandId">
            <summary>
            Gets command identifier.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="receivingError">error detected during receiving the request (e.g. deserialization error)</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.ReceivingError">
            <summary>
            Gets error detected during receiving the request (e.g. deserialization error)
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommand`2">
            <summary>
            The interface declares the reliable command.
            The command is able to receive typed request messages and return typed response messages.
            The command can be paused, resumed or canceled.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.ErrorReceived">
            <summary>
            The event is invoked when an error was detected during receiving the request. (e.g. a deserialization error)
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyConnected">
            <summary>
            The event is invoked when the command proxy was connected to the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyDisconnected">
            <summary>
            The event is invoked when the command proxy disconnected from the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening.
            </summary>
            <param name="duplexInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.OnMessageReceived(System.Object,Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs{Eneter.Messaging.EndPoints.Commands.CommandInputData{`1}})">
            <summary>
            The method is called when a request is received.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.CommandProcessingAsyncCallback(System.IAsyncResult)">
            <summary>
            The method is called when the asynchronous call to process the command is finished.
            (in case of parallel processing mode)
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.WorkingThreadHandler(Eneter.Messaging.EndPoints.Commands.CommandItem{`0,`1})">
            <summary>
            Removes the 'execute command' requests from the queue and execute them.
            The method is used in case of single thread mode.
            </summary>
            <param name="commandContext"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs">
            <summary>
            The event arguments used for the notification whether the message was delivered or not delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="messageId">id of the message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.MessageIdEventArgs.MessageId">
            <summary>
            Returns id of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory">
            <summary>
            Extends the communication by the buffered messaging and the network connection monitoring.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Buffered Messaging  --&gt; buffering messages if disconnected (while automatically trying to reconnect)</li>
            <li>Monitored Messaging --&gt; constantly monitoring the connection</li>
            <li>Messaging System    --&gt; responsible for sending and receiving messages</li>
            </ol>
            The buffer stores messages if the connection is not open. The connection monitor constantly checks if the connection
            is established. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory"/> and <see cref="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the 'ping' messages checking the connection is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
            <param name="maxOfflineTime">the maximum time, the messaging can work offline. When the messaging works offline,
            the sent messages are buffered and the connection is being reopened. If the connection is
            not reopen within maxOfflineTime, the connection is closed.
            </param>
            <param name="pingFrequency">how often the connection is checked with the 'ping' requests.</param>
            <param name="pingResponseTimeout">the maximum time, the response for the 'ping' is expected.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not maintain open
            connection, the connection monitoring is not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Notice, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            <br/>
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering as well as the connection monitoring are not applicable.
            This method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the unique id of this response receiver</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            time, the duplex output channel is disconnected and the buffered messaging (as the layer above) is notified about the
            disconnection.
            The buffered messaging then puts all sent response messages to the buffer and waits whether the duplex output channel reconnects.
            If the duplex output channel reopens the connection, the buffered response messages are sent.
            If the duplex output channel does not reconnect, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and rsponse messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory">
            <summary>
            Implements the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory">
            <summary>
            The interface declares the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connenction provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connection provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1">
            <summary>
            The event when a typed sequenced message is received.
            </summary>
            <typeparam name="_RequestType">The type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="receivingError">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1">
            <summary>
            The interface declares the typed messsage sender that can send the messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of the specified type as a fragment of a sequence.
            The sequence identifier is an id for the sequence and must be same for all sent messages belonging to the sequence.
            </summary>
            <param name="message">message fragment</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating whether this is the last fragment of the message and sequence is completed</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of specified type as a fragment of a sequence.
            </summary>
            <param name="message">typed message</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating if the sequence is completed</param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel">
            <summary>
            The interface declares methods to attach/detach IReliableInputChannel
            </summary>
            <remarks>
            For more details about the reliable input channel see <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.AttachReliableInputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel)">
            <summary>
            Attaches the reliable input channel and starts listening to messages.
            </summary>
            <param name="reliableInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.DetachReliableInputChannel">
            <summary>
            Detaches the reliable input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.IsReliableInputChannelAttached">
            <summary>
            Returns true if the reliable input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableReliableInputChannel.AttachedReliableInputChannel">
            <summary>
            Returns attached reliable input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed reliable message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            In addition it provides events notifying whether the respone message was delivered.
            The reliable typed message receiver can be used only with the reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the typed response message.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">respone message</param>
            <returns>id od the sent response message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed message sender opened connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed message sender was disconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message was not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1">
            <summary>
            The interface declares the typed messsage sender.
            The sender is able to send messages of the specified type via one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends the message of specified type via IOutputChannel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2">
            <summary>
            The interface declares the reliable command.
            The command is able to receive typed request messages and return typed response messages.
            The command can be paused, resumed or canceled.
            In additition the reliable command provides notifications whether the response messages were
            received by the reliable proxy command. <br/>
            The reliable command can be used only with reliable proxy command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ErrorReceived">
            <summary>
            The event is invoked when an error was detected during receiving the request. (e.g. a deserialization error)
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.CommandProxyConnected">
            <summary>
            The event is invoked when the command proxy was connected to the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.CommandProxyDisconnected">
            <summary>
            The event is invoked when the command proxy disconnected from the command.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the command proxy confirmed the response message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.IReliableCommand`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the command proxy does not confirm, that the response message was delivered.
            (If the message is not delivered within desired time.)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.AttachReliableInputChannel(Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening.
            </summary>
            <param name="duplexInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.DetachReliableInputChannel">
            <summary>
            Detaches the duplex input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.OnMessageReceived(System.Object,Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs{Eneter.Messaging.EndPoints.Commands.CommandInputData{`1}})">
            <summary>
            The method is called when a request is received.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.CommandProcessingAsyncCallback(System.IAsyncResult)">
            <summary>
            The method is called when the asynchronous call to process the command is finished.
            (in case of parallel processing mode)
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommand`2.WorkingThreadHandler(Eneter.Messaging.EndPoints.Commands.ReliableCommandItem{`0,`1})">
            <summary>
            Removes the 'execute command' requests from the queue and execute them.
            The method is used in case of single thread mode.
            </summary>
            <param name="commandContext"></param>
        </member>
        <member name="T:System.Collections.Generic.HashSet`1">
            <summary>
            Represents a set of values.
            </summary>
            <remarks>
            (This is a stripped down Silverlight port of the full .NET CLR's <see cref="T:System.Collections.Generic.HashSet`1" /> class.
            The API is feature complete and compatible
            except for serialization implementations which are not supported by Silverlight.
            Some private methods called in operations with other <see cref="T:System.Collections.Generic.IEnumerable`1" />s
            are not implemented by taking advantage of some unsafe bit-level optimization code
            in certain constellations, but otherwise should work the same.
            This implementation is copied using the Reflector and thus the copyright is fully at Microsoft.
            It will remain here until the HashSet is included in a future version of the Silverlight base class library.)
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Adds the specified element to a set.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; false if the element is already present.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.
            </summary>
            <param name="item">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy to array.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0 -or- count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">arrayIndex is greater than the length of the destination array -or- count is greater than the available space from the index to the end of the destination array.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="other">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <returns>A Enumerator object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object overlaps the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and other share at least one common element; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="item">The element to remove.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if item is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</returns>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in both itself and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Gets the number of elements that are contained in a set.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            Functionality to work with the router.
            </summary>
            <remarks>
            The router has attached more input channels and more output channels.<br/>
            When it receives some message via the input channel, it forwards the message to configured output channels.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            Declares the duplex channel unwrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel unwrapper' can communication only with 'duplex channel wrapper'.
            It cannot communicate with one-way 'channel wrapper'.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opened the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelUnwrapper">
            <summary>
            Declares the channel unwrapper.
            </summary>
            <remarks>
            The channel wrapper is listening to more input channels. When it receives some message,
            it wraps the message and sends it via the only output channel.
            On the other side the message is received by channel unwrapper. The unwrapper unwraps the message
            and uses the output channel to forward the message to the correct receiver.<br/>
            The message can be sent only one-way. For the bidirectional communication see <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper"/> and
            <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper"/>.<br/>
            Notice, the 'channel unwrapper' can communication only with 'channel wrapper'. It cannot communicate with 'duplex channel wrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelUnwrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel unwrapper receives a messae to be unwrapped and sent to the
            correct output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the broker request.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            The request is to subscribe to observe messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            The request is to unsubscribe from the observation.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage">
            <summary>
            The class represents the data structure used to send requests to the broker.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor">
            <summary>
            Default constructor used for serialization/deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Creates the request from input parameters.
            </summary>
            <param name="request">subscribe or unsubscribe request</param>
            <param name="messageTypes">message types that shall be subscribed or unsubscribed</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.Request">
            <summary>
            Returns type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.MessageTypes">
            <summary>
            Returns the array of message types.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase">
            <summary>
            Internal interface for implementing message systems.
            Note: This is just a helper interface helping implementation of some messaging system.
                  It is not mandatory to use this interface to implement the messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="channelId">channel id receiving the message</param>
            <param name="message">message to be sent</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the listener.
            </summary>
            <param name="channelId">channel id registering for receiving messages</param>
            <param name="messageHandler">method handling the incoming message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the listener.
            </summary>
            <param name="channelId">channel id to be unregistered from listening</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel">
            <summary>
            Declares the reliable duplex output channel.
            </summary>
            <remarks>
            It behaves like <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/> and can also be used everywhere where <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>
            is required.<br/>
            In addition, the reliable duplex output channel provides events <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/> and <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            The method <see cref="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.SendMessage(System.Object)"/> returns the message id.
            <br/><br/>
            The reliable duplex output channel can send messages to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            It cannot send messages to <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            Declares the duplex output channel that can send messages to the duplex input channel and receive response messages.
            </summary>
            <remarks>
            Notice, the duplex output channel works only with duplex input channel and not with input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the address represented by ChannelId.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is not open.</exception>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is already open.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform.
            If this method is executed in the main Silverlight thread, then in case of a failure the exception will not be propagated.
            It is recommended to execute this method in a different thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
            <remarks>
            Notice, this event is invoked in a different thread. The exception is only the Synchronous messaging that
            invokes this event in the thread calling the method SendResponseMessage in <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>.
            Also, in Silverlight (and Windows Phone 7), http and tcp messagings have the possibility
            to choose if the thread shall be the main Silverlight thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionOpened">
            <summary>
            The event is invoked when the connection with the duplex input channel was opened.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the duplex input channel was closed.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the id of the duplex input channel where messages are sent.
            It represents the address where messages are sent.
            </summary>
            <remarks>
            The channel id represents the communication address. The syntax of the channel id depends on the chosen
            communication. If the messaging is based on http, the address would be e.g.: http://127.0.0.1/Something/ or
            http://127.0.0.1:7345/Something/. If the communication is based on tcp, the address would be e.g.: tcp://127.0.0.1:7435/.
            For the named pipe, e.g. net.pipe://127.0.0.1/SomePipeName/.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns response receiving id of the duplex output channel.
            </summary>
            <remarks>
            The response receiver id is a unique identifier used by the duplex input channel to recognize
            connected duplex output channels.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel and listens to response messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel">
            <summary>
            The interface declares the composit duplex output channel.
            The composit duplex output channel is the duplex output channel that uses underlying duplex output channel
            to send messages and receive response mssages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel.UnderlyingDuplexOutputChannel">
            <summary>
            Returns the underlying duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the reliable duplex output channel.
            </summary>
            <param name="message">message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered to the reliable duplex input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered">
            <summary>
            The event is invoked if the message was not delivered until the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1">
            <summary>
            The interface declares the strongly typed message receiver.
            The receiver is able to receive messages of the specified type via one-way input channel.
            </summary>
            <typeparam name="_MessageDataType">
            Type of the message.
            </typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when a typed message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is rised when the message is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1">
            <summary>
            The typed message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the given error message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Implements the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml serializer. <br/>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the method factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">Type of sending messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            The event when a string response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2">
            <summary>
            The interface declares the command proxy.
            The command proxy is able to send the request to execute some activity in the respective command.
            The command proxy is also able to request pause, resume or cancel.
            It receive response messages from the command.
            </summary>
            <typeparam name="_ReturnDataType">Type of return data.</typeparam>
            <typeparam name="_InputDataType">Type of input data.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Pause(System.String)">
            <summary>
            Sends the pause request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Resume(System.String)">
            <summary>
            Sends the resume request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Cancel(System.String)">
            <summary>
            Sends the cancel request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1,System.String,System.Boolean)">
            <summary>
            Sends the execute request to the command.
            The input data is sent as a sequence.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
            <param name="sequenceId">input data sequence identifier</param>
            <param name="isSequenceCompleted">true - if the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.CommandResponseReceived">
            <summary>
            The event is invoked when the response message from the command was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandState">
            <summary>
            Enumerates possible commands states.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotApplicable">
            <summary>
            The state is not applicable.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotStarted">
            <summary>
            The command was not executed yet.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.InProgress">
            <summary>
            The execute request is in the progress.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Paused">
            <summary>
            The execute request is paused.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Completed">
            <summary>
            The execute request is completed.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Canceled">
            <summary>
            The execute request is canceled.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Failed">
            <summary>
            The execute request failed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandsFactory">
            <summary>
            Implements the factory to create command proxy and command.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandsFactory">
            <summary>
            The interface declares the factory to create command proxy and command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer.
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory)">
            <summary>
            Constructs the factory with the specified duplex typed sequenced messages factory.
            The duplex typed sequenced messages are used internally by the command (and command proxy) so
            you can provide your own implementation if needed.
            </summary>
            <param name="duplexTypedSequencedMessagesFactory">duplex typed sequenced messages factory</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
            <summary>
            Creates the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command</returns>
            <example>
            The following example shows how to implement the method performing a command,
            so that the method processes Pause, Resume, Cancel and Failures.
            <code>
            private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
            {
                try
                {
                    // Read the input data.
                    DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                    bool anInputData = anInputDataFragment.Data;    
            
                    for (int i = 0; i &lt; 100; ++i)
                    {
                        // Simulate some work.
                        Thread.Sleep(100);
            
                        // Wait if pause is requested.
                        if (commandContext.CurrentRequest == ECommandRequest.Pause)
                        {
                            // Notify the command proxy that the command was paused.
                            commandContext.ResponsePause();
            
                            // Wait until resumed or canceled.
                            commandContext.WaitIfPause();
                        }
            
                        // If the cancel is requested then stop the command.
                        // Note: The check for the cancel is placed after the check for the pause
                        //       because when the command is paused it can be canceled.
                        if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                        {
                            // Notify the command proxy that the command was canceled.
                            commandContext.ResponseCancel();
                            return;
                        }
            
                        // Notify the progress.
                        ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                        commandContext.Response(aState, i + 1);
                    }
                }
                catch (Exception err)
                {
                    commandContext.ResponseFailure(err.Message);
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor">
            <summary>
            The interface declares the fragment processor.
            The fragment processor is used to process incoming fragments. Fragment processors can implement
            various strategies how to process fragments.<br/>
            The fragment processor is intended to process one sequence of fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.SequenceId">
            <summary>
            Returns the sequence identifier processing by the fragment processor.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.IsWholeSequenceProcessed">
            <summary>
            Returns true if the whole sequence is processed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcher">
            <summary>
            Declares the dispatcher.
            </summary>
            <remarks>
            The dispatcher has attached more input channels and more output channels.<br/>
            When it receives some message via the input channel, it forwards the message to all output channels.<br/>
            This is the one-way dispatcher. It means it can forward messages but cannot route back response messages.<br/>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.AttachOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel)">
            <summary>
            Attaches the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel">
            <summary>
            Detaches all output channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel(System.String)">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.IsOutputChannelAttached">
            <summary>
            Returns true if at least one output channel is attached.
            </summary>
            <remarks>
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            Multiple output channel attachable means that the object can send messages to more receivers.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.AttachedOutputChannels">
            <summary>
            Returns attached output channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.AttachInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel)">
            <summary>
            Attaches the input channel.
            It stores the reference to the input channel and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel">
            <summary>
            Detaches the input channel.
            It cleans the reference to the input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel(System.String)">
            <summary>
            Detaches the input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.IsInputChannelAttached">
            <summary>
            Returns true if the reference to the input channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the true value does not mean the channel is listening.
            The method AttachInputChannel() starts also the listening, but if the listening stops (for whatever reason),
            the input channel stays attached. To figure out if the input channel is listening use property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.AttachedInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.Dispatcher.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when a message is received from an input channel.
            The message is then sent to all attached output channels.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapper">
            <summary>
            Declares the channel wrapper.
            </summary>
            <remarks>
            The channel wrapper is listening to more input channels. When it receives some message,
            it wraps the message and sends it via the only output channel.
            On the other side the message is received by channel unwrapper. The unwrapper unwraps the message
            and uses the output channel to forward the message to the correct receiver.<br/>
            The message can be sent only one-way. For the bidirectional communication see <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper"/> and
            <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper"/>.<br/>
            Notice, the 'channel wrapper' can communication only with 'channel unwrapper'. It cannot communicate with 'duplex channel unwrapper'.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Implements the factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            Declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates the channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transfering messages between threads by using the thread pool.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase">
            <summary>
            The abstract class implementing the interface for attaching multiple input channels.
            The class also contains functionality to send (forward) messages via duplex output channels - the duplex input channel
            from the message is forwarded is remembered.
            The duplex output channels used for forwarding are not attached but dynamically created as they are needed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IDuplexInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel nad starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            Detaching the input channel stops listening to the messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachedDuplexInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.CloseConnections(System.Collections.Generic.IEnumerable{Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection})">
            <summary>
            Closes given connections with client duplex output channel.
            </summary>
            <param name="connections"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            The interface declares the duplex string message sender.
            The duplex sender is able to send text messages and receive text responses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the message via the attached duplex output channel.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is invoked when a response message from duplex string message receiver was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.ErrorHandler">
            <summary>
            Internal helper class to trace typical messags.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.NamespaceDoc">
            <summary>
            Functionality for wrapping and unwrapping serialized data.
            </summary>
            <remarks>
            The wrapping functionality allows to extended already serialized data by some additional data.
            <example>
            The example shows how to extend already serialized data by time stamp.
            <code>
            // Serialization into the xml string.
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            
            // Get the time stamp.
            DateTime aTimeStamp = DateTime.Now;
            
            // Add the the time stamp to already serialized data.
            // Note: It creates the 'WrappedData' class containing both time stamp and original serialized data
            //       and serializes it by the provided serializer.
            object aWrappedSerializedData = DataWrapper.Wrap(aTimeStamp, anAlreadySerializedData, aSerializer)
            
            ...
            
            // Deserialization.
            // 1. Data must be unwrapped.
            WrappedData aWrappedData = DataWrapper.Unwrap(aWrappedSerializedData, aSerializer);
            
            // 2. Read the time stamp.
            DateTime aTimeStamp = (DateTime)aWrappedData.AddedData;
            
            // 3. Continue in processing of originally serialized data.
            object anOriginalSerializedData = aWrappedData.OriginalData;
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouter">
            <summary>
            Declares the one-way router.
            </summary>
            <remarks>
            The router has attached more input channels and more output channels.<br/>
            When it receives some message via the input channel, it forwards the message to all configured output channels.<br/>
            This the one-way router. Therefore, it can forward messages, but cannot route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.AddConnection(System.String,System.String)">
            <summary>
            Configures connection between the input channel and the output channel.
            When the connection is established then all messages comming via this input channel will be forwarded
            to all output channels configured for that output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes configured connection between the input channel and the output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveInputChannelConnections(System.String)">
            <summary>
            Removes all configured connctions for the given input channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveOutputChannelConnections(System.String)">
            <summary>
            Removes all configured connections for the given output channel.
            </summary>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            Declares the duplex channel wrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel wrapper' can communication only with 'duplex channel unwrapper'.
            It cannot communicate with one-way 'channel unwrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            The event arguments of the received message from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages synchronously in the caller thread.
            It creates output and input channels using the caller thread to deliver messages.
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to specified input channel using the synchronous local call.
            </summary>
            <param name="channelId">identifies the receiving input channel</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages on the specified channel id via the synchronous local call.
            </summary>
            <param name="channelId">identifies this input channel</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">identifies the response receiver of this duplex output channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to messages on the specified channel id.
            The duplex input channel can send response messages back to the duplex output channel.
            </summary>
            <param name="channelId">identifies this duplex input channel</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            The event data representing the response receiver id.
            The event is used for the communication between the duplex output channel and duplex input channel
            to identify where to send response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
            <param name="responseReceiverId">identifies the response message receiver</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns response message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory">
            <summary>
            Declares the factory for the reliable messaging system.
            </summary>
            <remarks>
            The reliable messaging system extends the underlying messaging system by the functionality providing the information
            whether the sent message was delivered or not.
            <br/><br/>
            Sending of the message from the <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>:<br/>
            <ol>
            <li>The reliable duplex output channel sends the message.</li>
            <li>The reliable duplex input channel receives the message and automatically sends back the acknowledgement.</li>
            <li>The reliable duplex output channel receives the acknowledging message and notifies, the message was delivered.</li>
            </ol>
            <br/><br/>
            Sending of the response message from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>:<br/>
            <ol>
            <li>The reliable duplex input channel sends the response message.</li>
            <li>The reliable duplex output channel receives the message and automatically sends back the acknowledgement.</li>
            <li>The reliable duplex input channel receives the acknowledging message and notifies, the response message was delivered.</li>
            </ol>
            <br/><br/>
            Notice, since <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel"/> and <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel"/> communicate oneway,
            the reliable communication with acknowledge messages is not applicable for them.
            Therefore, the factory just uses the underlying messaging system to create them.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            It provides notification whether the sent message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            It provides notification whether the sent message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">id of the response receiver</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receiver messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <remarks>
            It provides notification whether the sent response message was delivered or not.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2">
            <summary>
            The interface declares the reliable receiver for sequence of typed messages.
            The receiver is able to receive sequence of messages of specified type and response the sequence of messages
            of specified type. <br/>
            It is guaranteed the sequence is received in the same order as was sent. <br/>
            In addition, the reliable typed sequenced message reciever provides events notifying whether the response message was delivered.
            The reliable typed sequenced message reciever can be used only with the reliable typed sequenced message sender.
            <br/>
            <b>Note: Be aware that if the 'thread pool messaging system' is chosen the incoming messages
            are processed in more threads in parallel. Therefore the 'thread pool messaging system'
            cannot guarantee the order of incoming messages.</b> <br/>
            Consider to use the 'thread messaging system' instead.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.SendResponseMessage(System.String,`0,System.String,System.Boolean)">
            <summary>
            Sends the response message.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
            <returns>message id</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed sequenced message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed sequenced message sender closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the respponse message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message is not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs">
            <summary>
            The string message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.Message">
            <summary>
            Returns the received string message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            Implements the stream that can be written and read at the same time.
            </summary>
            <remarks>
            The dynamic stream supports writing of data by one thread and reading by another.
            The reading operation is blocked until the requested amount of data is not available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable. If called, it does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset">not applicable</param>
            <param name="origin">not applicable</param>
            <returns>not applicable</returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value">not applicable</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            </summary>
            <remarks>
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available - until data is written by another thread.
            </remarks>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            Returns true, because the stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            Returns false, because the stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            Returns true, because the stream supports writing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            Returns always 0.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            'Get' returns always 0. Set does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel wrapper receives a message from one of input channels.
            It wrapps the message and sends it to the output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider">
            <summary>
            The interface declares methods for convenient attaching of channels and
            for connecting senders and receivers with channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,System.String)">
            <summary>
            Creates and attaches the input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,System.String)">
            <summary>
            Creates and attaches the input channel to the component that can have attached multiple input channels.
            </summary>
            <param name="inputComponent">Component</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates and attaches the output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates and attaches the output channel to the component that can have attached multiple output channels.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component that can have attached multiple duplex input channels.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates and attaches the duplex output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">Input channel attachable component (receiver)</param>
            <param name="outputComponent">Output channel attachabel component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.MessagingSystem">
            <summary>
            Returns the messaging system used by the connection provider.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create reliable typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create reliable typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageSender``2">
            <summary>
            Creates the reliable typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageReceiver``2">
            <summary>
            reliable typed sequenced message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed sequenced message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with the xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified serializer.
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ReliableTypedSequencedMessagesFactory.CreateReliableTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2">
            <summary>
            The interface declares the reliable sender that sends sequences of typed messages.
            The sender is able to send sequences of typed messages and receive sequences of typed response messages.
            In addition, the sender provides events notifying whether the message was delivered.
            The reliable typed sequenced message sender can be used only with reliable typed sequenced message receiver.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
            <typeparam name="_RequestType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.SendMessage(`1,System.String,System.Boolean)">
            <summary>
            Sends the message.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
            <returns>message id</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked when the message was not delivered within the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender">
            <summary>
            The interface declares the reliable string message sender.
            The reliable string message sender can send string messages and receive string response messages.
            In addition it provides events notifying whether the messages were delivered.
            The reliable string message sender can be used only with the reliable string message receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the string message.
            </summary>
            <param name="message">text message</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.ResponseReceived">
            <summary>
            The event is invoked when a response message from the reliable string message receiver was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.MessageDelivered">
            <summary>
            The event is invoked when the sent message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageSender.MessageNotDelivered">
            <summary>
            The event is invoked when the sent message was not delivered within the specified time.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ReliableCommandProxy`2.myDuplexOutputChannelId">
            <summary>
            This is used only for trace purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1">
            <summary>
            The class is used by the eneter framework to transfer command return data.
            </summary>
            <typeparam name="_ReturnDataType">type of return data from the command</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor">
            <summary>
            Default constructor for deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String)">
            <summary>
            Constructs the class from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="state">command state</param>
            <param name="returnData">return data</param>
            <param name="errorMessage">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandState">
            <summary>
            State of the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ReturnData">
            <summary>
            Return data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ErrorMessage">
            <summary>
            Error message from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from XmlString.
            </summary>
            <remarks>
            The serializer internally uses XmlSerializer provided by .Net.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.AddConnection(System.String,System.String)">
            <summary>
            Creates the connection between the input channel and the output channel.
            One input channel can have configured connection with more output channels.
            When a message is received from the input channel the message is then forwarded to all
            output channels that are connected with the input channel.
            </summary>
            <param name="inputChannelId"></param>
            <param name="outputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.OnChannelMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called wehen the message is received.
            The message is then forwarded to all created connections.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages to the particular working thread.
            </summary>
            <remarks>
            Each input channel is represented by its own working thread removing messages from the queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be created by the same instance of ThreadMessagingSystemFactory.
            <br/><br/>
            Notice, the messages are always received in one particular working thread, but the notification events e.g. connection opened
            are invoked in a different thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system. <br/>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel via the message queue processed by the working thread.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel.</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel via the working thread.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">Identifies this input channel.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the working thread.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleOutputChannel">
            <summary>
            Internal basic implementation for the output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1">
            <summary>
            Data used for the typed sequenced response message fragment.
            The data is used to send response message from a duplex input channel to a duplex output channel.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality to sequence data.
            </summary>
            <remarks>
            The sequencing allows to put data into the sequence. The data in the sequence
            are ordered. The sequencing can be used in cases where data must be received in
            the same order as was sent. See also <see cref="N:Eneter.Messaging.EndPoints.TypedSequencedMessages"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            Declares the duplex router.
            </summary>
            <remarks>
            The duplex router has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel, it forwards the message to all configured duplex output channels.<br/>
            This router is bidirectional. Therefore, it can forward messages and also route back response messages from receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            Functionality to work with channel wrapper and channel unwrapper.
            </summary>
            <remarks>
            The channel wrapper and channel unwrapper helps to minimize the number of channels used for the communication.<be/>
            The channel wrapper can listen to more input channels. Then, when the it receives the message from one of these input channels,
            it wraps the message and forwards it via the only output channel.<br/>
            On the other side the message is received by the channel unwrapper (that listens to one input channel). The channel unwrapper
            unwraps the message and forwards it via the correct output channel to the receiver.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            Declares the broker client.
            </summary>
            <remarks>
            The broker client allows to send messages via the broker, so that broker will forward them to all subscribers.<br/>
            It also allows to subscribe for messages the client is interested to.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message of the specified type to the broker.
            </summary>
            <param name="messageTypeId">message type id</param>
            <param name="serializedMessage">
            message content. If the message is not a simple type then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes the client for the message.
            </summary>
            <param name="messageType">message type the client wants to observe</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes the client for messages.
            </summary>
            <param name="messageTypes">list of message types the client wants to observe</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the client from the specified message.
            </summary>
            <param name="messageType">message type the client does not want to observe anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes the client from specified messages.
            </summary>
            <param name="messageTypes">list of message types the client does not want to observe anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Unsubscribes the client from all messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed message is received from the broker.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory">
            <summary>
            Implements the factory creating channels for the reliable communication.
            </summary>
            <remarks>
            For more details about the reliable communication, refer to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableMessagingFactory"/>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 12 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize the acknowledge messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel by using the underlying messaging system.
            </summary>
            <remarks>
            Since the output channel communicates oneway, the acknowledge messaging is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel by using the underlying messaging system.
            </summary>
            <remarks>
            Since the input channel communicates oneway, the acknowledge messaging is not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">id of the response receiver</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.ReliableMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliableduplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive a sequence of strongly typed messages.
            It is guaranteed that the messages will be received in the correct order (same order as sent).<br/>
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1">
            <summary>
            The event when the typed sequenced message is received.
            </summary>
            <typeparam name="_MessageDataType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2">
            <summary>
            The interface declares the duplex sender that sends sequences of strongly typed messages.
            The sender is able to send sequences of typed messages and receive sequences of typed response messages.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.SendMessage(`1,System.String,System.Boolean)">
            <summary>
            Sends typed message.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with the xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified serializer.
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            The event when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends message via the output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Declares the event type when the request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver">
            <summary>
            The interface declares the reliable string message receiver.
            The reliable string message receiver can receiver string messages and response string messages.
            In addition it provides events notifying whether the response messages were delivered.
            The reliable string message receiver can be used only with the reliable string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the connected reliable string message sender.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
            <returns>id of the respones message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a reliable string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a reliable string message sender closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IReliableStringMessageReceiver.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the respone message was not delivered within the specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            The interface declares the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandRequest">
            <summary>
            Enumerates requests the command can receive.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Execute">
            <summary>
            The command is asked to execute the activity.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Pause">
            <summary>
            The command is asked to pause.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Resume">
            <summary>
            The command is asked to resume.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Cancel">
            <summary>
            The command is asked to cancel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            Functionality for diagnostic (tracing and debugging) purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            Implements the functionality for tracing info, warning and error messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message">information message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.String)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.String)">
            <summary>
            Traces the error message and details for the error.
            </summary>
            <param name="message">error message</param>
            <param name="errorDetails">error details</param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory">
            <summary>
            The factory class provides methods to create fragment processors.
            The fragment processors provides strategies to process incoming fragments of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateFragmentSequencer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and continuously returns the sequence of ordered fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateSequenceFinalizer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and when the whole sequence is collected it returns it.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateMultiinstanceFragmentProcessor(System.Func{System.String,Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor})">
            <summary>
            Creates the fragment processor able to process more sequences at once.
            </summary>
            <param name="fragmentProcessorFactoryMethod">
            Factory method used to create processors for particular sequences.
            Note: CreateFragmentSequencer() and CreateSequenceFinalizer() from this factory class can be used as factory methods.
            </param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1">
            <summary>
            Implements the data fragment for specified data type.
            </summary>
            <typeparam name="_DataType">data type contained in the fragment</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor">
            <summary>
            Default constructor used for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from parameters.
            </summary>
            <param name="data">Data contained in the fragment.</param>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Number of the fragment.</param>
            <param name="isFinal">Indicates whether the fragmant is the last one.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.Data">
            <summary>
            Data contained in the fragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            Declares the duplex dispatcher.
            </summary>
            <remarks>
            The duplex dispatcher has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel it forwards the message to all duplex output channels.<br/>
            The duplex dispatcher allows the bidirectional communication. It means, receivers to whom the message was forwarded can
            sand back response messages. Therefore, the sender can get response messages from all receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel">
            <summary>
            Internal basic implementation of the input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StartListening">
            <summary>
            Registers the delegate in the messaging system to receive messages from a desired channel id and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StopListening">
            <summary>
            Unregisters the channel id from the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.HandleMessage(System.Object)">
            <summary>
            Handles the received message from the message system.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs">
            <summary>
            The event data available when the input channel receives a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event data from the input parameters.
            </summary>
            <param name="channelId">channel identifier</param>
            <param name="message">message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.ChannelId">
            <summary>
            Returns the channel identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.#ctor(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs Http duplex output channel.
            The Http duplex output channel can send messages and receive responses from Http duplex input channel.
            </summary>
            <param name="channelId">Uri address of Http duplex input channel.</param>
            <param name="responseReceiverId">response receiver identifier</param>
            <param name="pollingFrequencyMiliseconds">How often the pulling for response messages will occur.</param>
            <param name="isResponseReceivedInSilverlightThread">indicates if the response messages are notified in the silverlight thread</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.OpenConnection">
            <summary>
            Starts pulling for response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.CloseConnection">
            <summary>
            Stops pulling for response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.HandleResponseMessage(System.Object)">
            <summary>
            Handles response messages from the queue.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.ChannelId">
            <summary>
            Returns the channel id. - the channel id is Uri.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the connection is open.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1">
            <summary>
            Data used for the typed sequenced message fragment.
            The data is used to send the message fragment from a duplex output channel to a duplex input receiver.
            </summary>
            <typeparam name="_RequestType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed reliable message sender.
            The reliable sender can send typed messages and receive typed response messages.
            In addition it provides events notifying whether the message was delivered.
            The reliable typed message sender can be used only with the reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the message to the reliable typed message receiver.
            </summary>
            <param name="message">message of desired type</param>
            <returns>id of the message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked if the event is not delivered within a specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2">
            <summary>
            The interface represents the context of the particular command execution.
            It is passed as the input parameter to the method performing the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.DequeueInputData">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until the input data fragment is received.<br/>
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <returns>data fragment wrapping the input data</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.DequeueInputData(System.Int32)">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until
            the input data fragment is received or the specified timeout occured.
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time for the input data. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>data fragment wrapping the input data</returns>
            <exception cref="T:System.TimeoutException">when the maximum waiting time for the input data is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.WaitIfPause">
            <summary>
            If the pause is the current request then it blocks the calling thread until resumed or canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.WaitIfPause(System.Int32)">
            <summary>
            If the pause is requested then it blocks the calling thread until resumed or canceled.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time in miliseconds</param>
            <returns>true if the timeout did not occur</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponsePause">
            <summary>
            Notifies the command proxy that the command was paused.
            </summary>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponseCancel">
            <summary>
            Notifies the command proxy that the command was canceled.
            </summary>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.ResponseFailure(System.String)">
            <summary>
            Notifies the command proxy that the command failed.
            </summary>
            <param name="errorMessage">error message</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0)">
            <summary>
            Sends the return data to the command proxy.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean)">
            <summary>
            Sends the return data to the command proxy.
            The method can be used if the return data is sent in more fragments.
            E.g. If the command wants to notify progress or some partial results.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <param name="sequenceId">identifies the sequence where the fragment of return data belongs</param>
            <param name="isReturnDataSequenceCompleted">true if this is the last fragment of the sequence</param>
            <returns>Id of the response message.</returns>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CommandProxyId">
            <summary>
            Returns identifier of the command proxy that executed this command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CommandId">
            <summary>
            Returns identifier of this command. (If one command proxy executes more commands, then they can be recognized with this id.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.NumberOfInputData">
            <summary>
            Returns number of input data in the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.CurrentRequest">
            <summary>
            The currently set request for the command e.g. Pause, Resume or Cancel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.IReliableCommandContext`2.IsCommandProxyConnected">
            <summary>
            Returns true if the command proxy that executed the command is still connected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Implements the thread that processes messages from the message queue.
            When the messages are received the thread calls the callback specified by the user.
            </summary>
            <typeparam name="_MessageType">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor">
            <summary>
            Constructs the working thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor(System.String)">
            <summary>
            Constructs the working thread with the specified name.
            </summary>
            <param name="workingThreadName">name of the thread</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the callback method handling the messages and starts the 'working thread' processing the
            message queue and calling the callback if the message is received.
            </summary>
            <param name="messageHandler">Callback called from the working thread to process the message</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the message handler is already registered.</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the message callback message handler and releases the thread.
            If the thread does not stop within 5 seconds it is aborted.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Puts the message to the queue.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.Worker">
            <summary>
            Worker method cycling to take messages from the queue and calling the registered handler to process them.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.myMessageHandler">
            <summary>
            Handler called to process the message from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.RouterFactory">
            <summary>
            Implements the factory creating the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouterFactory">
            <summary>
            Declares the factory creating the one-way router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.RouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements the factory to create the bidirectional dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            Declares the factory to create the bidirectional dispatcher.
            </summary>
            <remarks>
            The bidirectional dispatcher sends messages to all duplex output channels and also can route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Implents the factory creating broker and broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with BinarySerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage">
            <summary>
            The data representing the message sent to the broker to notify subscribed clients.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the message data from the input parameters.
            </summary>
            <param name="messageTypeId">Type of the notified message.</param>
            <param name="message">Message content.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.MessageTypeId">
            <summary>
            Type of the notified message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.Message">
            <summary>
            Serialized message that shall be notified to subscribers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages with using .Net thread pool.
            </summary>
            <remarks>
            The messages are put to the queue of .Net thread pool. The receiving input channel is then called
            in the context of the assigned thread from the pool. Therefore the input channel can process more messages at once
            and also can notify the subscriber from more different threads at the same time. <br/>
            <b>Therefore do not forget to be careful and avoid race conditioning.</b>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the specified input channel via the thread pool.
            </summary>
            <remarks>
            The output channel can send messages only to the input channel and not to the duplex input channel.
            </remarks>
            <param name="channelId">Identifies the receiving input channel.</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel via the thread pool.
            </summary>
            <remarks>
            The input channel can receive messages only from the output channel and not from the duplex output channel.
            </remarks>
            <param name="channelId">Identifies this input channel.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs">
            <summary>
            Event argument containing channel id and response receiver id.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="channelId">channel id</param>
            <param name="responseReceiverId">response receiver id</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ChannelId">
            <summary>
            Returns the channel id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1">
            <summary>
            The interface declares the typed message receiver that receives the sequence of messages.
            It is guaranteed the received sequence has the same order as was sent.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message (as a fragment of the sequence) is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            The interface declares the reliable string message receiver.
            The reliable string message receiver can receiver string messages and response string messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the duplex string message sender.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex string message sender closed the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentSequencer.#ctor(System.String)">
            <summary>
            The constructor initializes the sequencer for a particular instance.
            </summary>
            <param name="sequenceId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transfering messages between threads by using the working
            thread processing messages from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            Interfaces representing the messaging system.
            </summary>
            <remarks>
            The messaging system is responsible for delivering messages from a sender to a receiver through communication channels.
            <br/><br/>
            For the one-way communication, the messaging system provides the output channel and the input channel.
            The output channel sends messages to the input channel with the same channel id.
            <br/><br/>
            For the bidirectional communication, the messaging system provides the duplex output channel and the duplex input channel.
            The duplex output channel sends messages to the duplex input channel with the same channel id and can receive response messages.
            The duplex input channel receives messages and can send back response messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory">
            <summary>
            Extends the communication by reliable messaging and buffered messaging.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirms, the sent message was delivered</li>
            <li>Buffered Messaging  --> buffering messages if disconnected (while automatically trying to reconnect)</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the reliable messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize the acknowledge communication</param>
            <param name="acknowledgeTimeout">the maximum time, until the acknowledge message is expected. If the time is exceeded
            it will be notified, the message was not delivered.</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not receive messages,
            the reliable messaging is not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering as well as reliable messages are not applicable.
            This method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            If the reliable duplex input channel receives the message, it sends back the acknowledge message.
            When the reliable duplex output channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the reliable duplex output channel that can send messages and receive response messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            If the reliable duplex input channel receives the message, it sends back the acknowledge message.
            When the reliable duplex output channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel.MessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels</param>
            <returns>reliable duplex output channnel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the reliable duplex input channel that can receive messages from <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/> and send back
            response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the buffered messaging.
            If the connection is not established, it puts sent response messages to the buffer.
            If the reliable duplex output channel receives the response message, it sends back the acknowledge message.
            When the reliable duplex input channel receives the acknowledge message it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageDelivered"/>.
            If the acknowledge message is not delivered until the specified time, it invokes <see cref="E:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel.ResponseMessageNotDelivered"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channnel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType">
            <summary>
            Type of the message sent by the monitor duplex output channel or monitor dupolex input channel.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Ping">
            <summary>
            The message checking the connection. This type of message is sent by the monitor duplex output channel to check the conneciton.
            It is also used by the monitor duplex input channel to response the 'ping' check.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Message">
            <summary>
            The message is some message or response message containing data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage">
            <summary>
            The message used by the monitor duplex output channel or monitor duplex input channel for the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor">
            <summary>
            Constructs the message. This constructor is used by the Xml serializer for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType,System.Object)">
            <summary>
            Constructs the message from specified parameters.
            </summary>
            <param name="messageType">type of the message, ping or regular message</param>
            <param name="messageContent">message content, in case of ping this parameter is not used</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageType">
            <summary>
            Type of the message. Ping or regular message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageContent">
            <summary>
            Message. In case of the 'ping', this property is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.AesSerializer">
            <summary>
            Serializer using AES (Advanced Encryption Standard).
            </summary>
            <remarks>
            The serializer internally uses some other serializer to serialize and deserialize data.
            Then it uses AES to encrypt and decrypt the data.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            AesSerializer aSerializer = new AesSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using AES.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            <br/><br/>
            Notice, since AesSerializer serializes into array of bytes, it is not possible to use this serializer
            for the communication between two Silverlight applications. The communication between two silverlight applications
            requires, that data is serialized into the string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 256 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 256 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 256 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            Functionality to work with the dispatcher.
            </summary>
            <remarks>
            The dispatcher receives messages and forwards them to all attached receivers. (it multiplies the message)
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory">
            <summary>
            Implements the factory to create the one-way dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory">
            <summary>
            Declares the factory creating the one-way dispatcher.
            </summary>
            <remarks>
            The one-way dispatcher sends messages to all attached output channels.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            The event data available when the duplex input channel receives a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">channel identifier</param>
            <param name="message">message</param>
            <param name="responseReceiverId">identifies the client receiving response messages</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory">
            <summary>
            Extends the communication by reliable messaging, buffered messaging and monitored network connection.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirmation, whether the sent messages were delivered.</li>
            <li>Buffered Messaging  --> stores sent messages to the buffer if disconnected</li>
            <li>Monitored Messaging --> constantly monitores the connection</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The serializer for reliable messages and for 'ping' messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize acknowledge messages and 'ping' messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            This output channel provides the buffered messaging. Since the the output channel does not receive messages,
            and also does not maintain the open connection, the reliable messaging and also the connection monitoring are not applicable.<br/>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel does not maintain the open connection and also does not send messages,
            the reliable messaging, the buffered messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the buffered messaging layer. The buffered messaging layer then stores sent messages in the buffer
            and tries to reconnect. If the connection is reopen, the messages from the buffer are sent. If not, it notifies,
            the connection was closed and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the buffered messaging layer. The buffered messaging layer then stores sent messages in the buffer
            and tries to reconnect. If the connection is reopen, the messages from the buffer are sent. If not, it notifies,
            the connection was closed and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">
            the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels
            </param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableBufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the reliable messaging, the buffered messaging and the connection monitoring.
            The connection monitoring constantly checks, if the duplex output channel is still connected. If the
            duplex output channel does not 'ping' anymore, the duplex output channel is disconnected and 
            it the buffered messaging layer is notified about the disconnection.
            The buffered messaging layer then stores sent response messages to the buffer and waits if the connection
            with the duplex output channel is established again.
            If the connection is reopen, the messages from the buffer are sent.
            If not, it notifies, the duplex output channel is disconnected and messages are deleted from the buffer.<br/>
            The reliable messaging notifies whether the sent response messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter">
            <summary>
            The helper allowing to observe the particular duplex output channel.
            If the channel is disconnected, it tries to reopen the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Constructs the reconnecter that tries to reconnect infinitely every second.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel,System.TimeSpan,System.Int32)">
            <summary>
            Constructs the reconnecter from specified parameters.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
            <param name="reconnectFrequency">how often the reconnect attempt shall be performed (in case of the disconnection)</param>
            <param name="maxReconnectAttempts">max amounts of reconnect attempts. If exceeded, the ReconnectingFailed is invoked.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.EnableReconnecting">
            <summary>
            Enables the automatic reconnecting in case the disconnect is notified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.DisableReconnecting">
            <summary>
            Disables the automatic reconnecting.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionClosed">
            <summary>
            The event is invoked when the observed duplex output channel notified, that the connection was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionOpened">
            <summary>
            The event is invoked when the duplex output channel was reconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ReconnectingFailed">
            <summary>
            The event is invoked when the reopenning of the duplex output channel failed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.IsReconnectingEnabled">
            <summary>
            Returns true if the reconnecting is enabled.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.NamespaceDoc">
            <summary>
            Buffering of messages in case the network connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages while the network connection is not available.
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be anytime interrupted. In case of the disconnection, the sent messages are stored
            in the memory buffer while the connection tries to be automatically reopen. If the reopen is successful and the connection
            is established, the messages are sent from the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. In case the application receiving
            messages is not up, the sent messages are stored in the buffer. Then when the receiving application is running, the messages
            are automatically sent from the buffer.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory">
            <summary>
            Extends the messaging system by a buffer storing messages while the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages while the network connection is not available.
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be anytime interrupted. In case of the disconnection, the sent messages are stored
            in the memory buffer while the connection tries to be automatically reopen. If the reopen is successful and the connection
            is established, the messages are sent from the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. In case the application receiving
            messages is not up, the sent messages are stored in the buffer. Then when the receiving application is running, the messages
            are automatically sent from the buffer.
            <br/>
            <br/>
            The buffering is applied for sent messages. It means, the buffering is applied for 'output channel', 'duplex output channel'
            and 'duplex input channe' (for sending response messages). It is not applicable for input channel.
            <br/><br/>
            <b>Note</b><br/>
            The buffered messaging does not require, that both communicating parts create channels with buffered messaging factory.
            It means, e.g. the duplex output channel created with buffered messaging with underlying TCP, can send messages
            directly to the duplex input channel created with just TCP messaging factory.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The maximum offline time will be set to 10 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan)">
            <summary>
            Constructs the factory from the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            If the input channel is not available, the sent messages are stored in the buffer from where they are sent again
            when the input channel is available.
            If the message is not sent from the buffer (because the input channel is not available) within the specified offline time,
            the message is removed from the buffer.
            <br/>
            Note, when the message was successfully sent, it does not mean the message was delivered. It still can be lost on the way.
            <br/>
            The returned output channel is the composite channel. Therefore, if you need to reach underlying channels,
            you can cast it to <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            The buffering functionality is not applicable for the input channel.
            Therefore, this method just uses the underlying messaging system to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the messages are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            re deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/> </returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the message are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            re deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of this duplex output channel</param>
            <returns>composit duplex output channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            If the connection with the duplex output channel is not established, it puts sent response messages to the buffer.
            Then, when the duplex input channel is connected, the response messages are sent.
            If the duplex output channel does not connect within the specified maximum offline time, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and rsponse messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the sequences typed messages factory with xml string serializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the sequenced typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory">
            <summary>
            Implements the factory to create reliable command proxy and reliable command.
            The reliable 'command proxy' and 'command' send acknowledge messages as a confirmation that the request
            or the resposne was delivered.<br/>
            The reliable command proxy can be used only with reliable command.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory">
            <summary>
            The interface declares the factory to create reliable command proxy and reliable command.
            The reliable 'command proxy' and 'command' send acknowledge messages as a confirmation that the request
            or the resposne was delivered.<br/>
            The reliable command proxy can be used only with reliable command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory.CreateReliableCommandProxy``2">
            <summary>
            Creates the reliable command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>reliable command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.IReliableCommandsFactory.CreateReliableCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.IReliableCommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the reliable command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>reliable command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer.<br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.IReliableTypedSequencedMessagesFactory)">
            <summary>
            Constructs the factory with the specified duplex typed sequenced messages factory.
            The duplex typed sequenced messages are used internally by the command (and command proxy) so
            you can provide your own implementation if needed.
            </summary>
            <param name="reliableTypedSequencedMessagesFactory">duplex typed sequenced messages factory</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.CreateReliableCommandProxy``2">
            <summary>
            Creates the reliable command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>reliable command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ReliableCommandsFactory.CreateReliableCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.IReliableCommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the reliable command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>reliable command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.CommandProxy`2.myDuplexOutputChannelId">
            <summary>
            This is used only for trace purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer">
            <summary>
            The class collects and sorts incoming fragments.
            When all fragments are collected the ProcessFragment method returns the fragment of sorted fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.#ctor(System.String)">
            <summary>
            The constructor initializes the finalizer for the given instance id.
            </summary>
            <param name="sequenceId">sequence that the finalizer processes</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            The method puts incoming fragment to the sequenece.
            It returns the collection when all fragments are collected and sorted.
            </summary>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.mySortedFragments">
            <summary>
            The collection collects ordered fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.SequenceId">
            <summary>
            Returns the instance id.
            The instance id specifies which fragments belong together.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.IsWholeSequenceProcessed">
            <summary>
            Returns true if all fragments have been processed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.FragmentSequencer">
            <summary>
            The sequencer for sequencing of fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for queueing and processing messages with multiple threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.NamespaceDoc">
            <summary>
            The reliable messaging, providing the confirmation if the sent message was delivered.
            </summary>
            <remarks>
            The reliable messaging provides the information whether the sent message was delivered.
            If the sent message was delivered, the receiver automatically sends back the acknowledge message.
            If the sender receives the acknowledge message, it notifies, the message was delivered.
            If the sender does not receive the acknowledge message within a specified timeout, it notifies, the message
            was not delivered.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory">
            <summary>
            The interface declares the factory to create reliable typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive simple text messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer">
            <summary>
            Provides functionality to read and write specific messages internaly used by duplex channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.ReadMessage(System.IO.Stream)">
            <summary>
            Reads the message from the stream.
            </summary>
            <param name="readingStream">stream to be read</param>
            <returns>message</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteMessage(System.IO.Stream,System.Object)">
            <summary>
            Writes the message to the specified stream.
            </summary>
            <param name="writingStream"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteOpenConnectionMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by duplex output channels to open connection with the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.GetOpenConnectionMessage(System.String)">
            <summary>
            Returns the low level communication message used by duplex output channels to open
            connection with duplex input channel.
            </summary>
            <param name="responseReceiverId"></param>
            <returns>Communic</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsOpenConnectionMessage(System.Object)">
            <summary>
            Returns true if the given message is the open connection message used by the duplex output channel
            to open connection.
            </summary>
            <param name="message">Message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteCloseConnectionMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by the duplex output channel to close the connection with the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.GetCloseConnectionMessage(System.String)">
            <summary>
            Returns the low level communication message used by duplex output channel to close
            the connection with duplex input channel.
            </summary>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsCloseConnectionMessage(System.Object)">
            <summary>
            Returns true if the given message is the message used by the duplex output channel to close
            the connection.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteRequestMessage(System.IO.Stream,System.String,System.Object)">
            <summary>
            Writes the request message used by the duplex output channel to send to the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
            <param name="message">Request message.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsRequestMessage(System.Object)">
            <summary>
            Returns true if the given message is the request message used by the duplex output channel to send
            a message to the duplex input channel.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WritePollResponseMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by the duplex output channel to poll response messages from the
            duplex input channel. The message is used in case of Http messaging.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsPollResponseMessage(System.Object)">
            <summary>
            Returns true if the given message is the essage used by the duplex output channel to poll
            messages from the duplex input channel. (in case of Http)
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            Declares the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.NamespaceDoc">
            <summary>
            Helper functionality to create and attach channels to components.
            </summary>
            <remarks>
            This connecting functionality helps to reduce amount of coding when channels are created and attached to components.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1">
            <summary>
            Event when the typed sequenced response message is received.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the response message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message has received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            The event when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory">
            <summary>
            Implements the factory to create reliable typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml string serializer. <br/>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates the reliable message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates the reliable message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from an xml string.
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue">
            <summary>
            Implements the queue for messages of type object.
            One or more threads can put messages into the queue and other threads
            can remove messages from the queue.
            If the queue is empty, then the thread reading the messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1">
            <summary>
            Implements the message queue.
            One or more threads can put messages into the queue and other threads
            can remove messages from the queue.
            If the queue is empty, then the thread reading the messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
            <typeparam name="_MessageType">Type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.EnqueueMessage(`0)">
            <summary>
            Puts messages to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>
            message, it returns null if the waiting thread was unblocked but there is no message in the queue.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage(System.Int32)">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <param name="millisecondsTimeout">
            Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.
            </param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage().
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.WaitForQueueCall(System.Func{`0})">
            <summary>
            Waits until something is in the queue and then calls the specified delegate.
            If the waiting thread is released (by UnblockProcessingThreads) but the queue is still empty, it returns the default
            value of the specified template type.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestInvoker.InvokeNotInSilverlightThread(System.Uri,System.Object)">
            <summary>
            This method is workaround for the Silverlight bug.
            The problem is, that when the asynchronous HttpRequest is invoked, it is not possible to wait
            in the Silverlight thread until it is completed. --> It hangs.
            
            In Windows Phone 7 the problem does not occur.
            </summary>
            <param name="anAddress"></param>
            <param name="request"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.NamespaceDoc">
            <summary>
            Functionality extending the default behavior of messaging systems.
            </summary>
            <remarks>
            E.g.: Buffering of sent messages, reliable communication or network connection monitoring.<br/>
            The extensions are realized by so called 'composites'. The composite is a messaging system derived from
            <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory"/> that implements the extending functionality but for the communication
            it uses other (underlying) messaging system. It means, e.g. if you wish the buffered messaging for the TCP based communication,
            you can create the buffered messaging system using the TCP as the underlying messaging system.
            <example>
            Creating of the buffered messaging using the TCP as the underlying messaging system.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create the buffered messaging using TCP as the underlying messaging.
            IMessagingSystemFactory aBufferedMessaging = new BufferedMessagingFactory(anUnderlyingMessaging);
            </code>
            </example>
            Therefore, messaging systems can be composed into layers providing the desired functionality. It is also possible
            to use a composite messaging system as the underlying messaging.
            <example>
            Creating the TCP based messaging system constantly checking the network connection and providing the buffer
            for sent messages in case of the disconnection.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
            // Create the composite providing the network connection monitor.
            IMessagingSystemFactory aMonitoredMessaging = new MonitoredMessagingFactory(aTcpMessaging);
            
            // Create the composite providing the buffer used for the sent messages in case of the disconnection.
            IMessagingSystemFactory aBufferedMonitoredMessaging = new BufferedMessagingFactory(aMonitoredMessaging);
            
            
            ...
            
            // Create the duplex output channel, that monitores the network connection and buffers sent messages if disconnected.
            IDuplexOutputChannel aDuplexOutputChannel = aBufferedMonitoredMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:6080/");
            
            </code>
            </example>
            To simplify the implementation, there are already pre-implemented typically composed messaging systems.
            E.g.: <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory"/>. It is the messaging system that is composed from the following
            layers:
            <br/>
            <ol>
            <li>Reliable Messaging  --&gt; provides acknowledged messages.</li>
            <li>Monitored Messaging --&gt; constantly checks the connection.</li>
            <li>Messaging System    --&gt; a real messaging system transferring messages, e.g. TCP messaging system.</li>
            </ol>
            <example>
            Using the pre-implementated messaging to create the reliable communication (acknowledged messages) and with monitored
            network connection.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
            // Create the messaging system using the reliable communcation and the monitoring the network connection.
            IReliableMessagingFactory aReliableMessaging  = new ReliableMessagingFactory(aTcpMessaging);
            </code>
            </example>
            <br/>
            Notice, that the communicating applications (or components) must use the same composite messaging system to be able to communicate.
            E.g. if the server application uses ReliableMonitoredMessagingFactory then also the client must use ReliableMonitoredMessagingFactory.
            Otherwise, they will not understand each other.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory">
            <summary>
            Extends the communication by reliable messaging and monitored network connection.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Reliable Messaging  --> confirmation, whether the sent messages were delivered.</li>
            <li>Monitored Messaging --> constantly monitores the connection</li>
            <li>Messaging System    --> responsible for sending and receiving messages</li>
            </ol>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The serializer for reliable messages and for 'ping' messages is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 11 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2s. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize acknowledge messages and 'ping' messages</param>
            <param name="acknowledgeTimeout">the maximum time until the delivery of the message must be acknowledged</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel sending messages to the input channel.
            </summary>
            <remarks>
            Since the output channel communicates oneway and does not maintain the open connection,
            the reliable messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the output channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel receiving messages from the output channel.
            </summary>
            <remarks>
            Since the input channel does not maintain the open connection and also does not send messages,
            the reliable messaging and the connection monitoring are not applicable.
            Therefore, the implementation of the method just uses the underlying messaging to create the input channel.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the connection was closed.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the connection is established. If the connection is broken,
            it notifies the connection was closed.<br/>
            The reliable messaging notifies whether the sent messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexOutputChannel"/>.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">
            the response receiver id used by the duplex input channel to distinguish between
            connected duplex output channels
            </param>
            <returns>reliable duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.ReliableMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the reliable messaging and the connection monitoring.
            The connection monitoring constantly checks, if the duplex output channel is still connected. If the
            duplex output channel does not 'ping' anymore, the duplex output channel is disconnected.<br/>
            The reliable messaging notifies whether the sent response messages were delivered. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.ReliableMessagingComposit.IReliableDuplexInputChannel"/>.
            </remarks>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.NamespaceDoc">
            <summary>
            Network connection monitoring between communicating applications.
            </summary>
            <remarks>
            The network connection monitoring constantly monitors whether the connection is open.
            The monitoring is realized by sending 'ping' messages and receiving 'ping' responses.
            If the sending of the 'ping' fails or the 'ping' response is not received within the specified
            timeout, the connection is considered to be disconnected.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            Interfaces used by components to be able to attach channels.
            </summary>
            <remarks>
            If some communication component implements e.g. IAttachableDuplexInputChannel, then such
            component can start listening to messages and send back response messages.<br/>
            If some communication componnent implements e.g. IAttachableOutputChannel, then the component
            is able to send one-way messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive strongly typed messages of specified type.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1">
            <summary>
            Event data when the response from the command was received.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="commandState">state of the command</param>
            <param name="returnData">return data coming from the command</param>
            <param name="sequenceId">return data sequence id</param>
            <param name="isSequenceCompleted">tru - if the sequence of return data is completed</param>
            <param name="commandError">error message coming from the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event data when an error was detected during receiving the response.
            (e.g. a deserialization error)
            </summary>
            <param name="receivingError"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandState">
            <summary>
            Gets command state.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReturnData">
            <summary>
            Gets return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Gets the sequence is of return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true - if the sequence of return data is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an error detected during receiving the response. (e.g. deserialization error)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandError">
            <summary>
            Returns an error message coming from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandId">
            <summary>
            Returns command identifier.
            </summary>
        </member>
    </members>
</doc>
