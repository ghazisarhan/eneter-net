<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework.Silverlight</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouter">
            <summary>
            The interface declares the router.
            The router receives messages from attached input channels and forwards them to configured
            output channels.<br/>
            Sequence:
            1. A message is received from the input channel.<br/>
            2. The router finds all output channels configured for the receiving input channel.<br/>
            3. The router forwards the message through all configured output channels.<br/>
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IInputChannel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel">
            <summary>
            The interface declares the API to attach/detach one IInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.AttachInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel)">
            <summary>
            Attaches the input channel.
            Attaching of the input channel starts the listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.DetachInputChannel">
            <summary>
            Detaches the input channel.
            Detaching the input channel stops listening to the messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel.IsInputChannelAttached">
            <summary>
            Returns true if the input channel is attached.
            If the input channel is attached it means the object that has attached the channel is listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel">
            <summary>
            Detaches all input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.DetachInputChannel(System.String)">
            <summary>
            Detaches the input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleInputChannels.IsInputChannelAttached">
            <summary>
            Returns true if at least one input channel is attached.
            If the input channel is attached it means the object that has attached the channel is listening to messages.
            Multiple input channel attachable means that the object is listening to more input channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IOutputChannel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel">
            <summary>
            The interface declares the API to attach/detach one IOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.AttachOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel)">
            <summary>
            Attaches the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.DetachOutputChannel">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel.IsOutputChannelAttached">
            <summary>
            Returns true if the output channel is attached.
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel">
            <summary>
            Detaches all output channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.DetachOutputChannel(System.String)">
            <summary>
            Detaches the output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels.IsOutputChannelAttached">
            <summary>
            Returns true if at least one output channel is attached.
            If the output channel is attached it means the object that has attached the channel
            can send messages.
            Multiple output channel attachable means that the object can send messages to more receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.AddConnection(System.String,System.String)">
            <summary>
            Configures connection between the input channel and the output channel.
            When the connection is established then all messages comming via this input channel will be forwarded
            to all output channels configured for that output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes configured connection between the input channel and the output channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveInputChannelConnections(System.String)">
            <summary>
            Removes all configured connctions for the given input channel.
            </summary>
            <param name="inputChannelId">input channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouter.RemoveOutputChannelConnections(System.String)">
            <summary>
            Removes all configured connections for the given output channel.
            </summary>
            <param name="outputChannelId">output channel identifier</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.AddConnection(System.String,System.String)">
            <summary>
            Creates the connection between the input channel and the output channel.
            One input channel can have configured connection with more output channels.
            When a message is received from the input channel the message is then forwarded to all
            output channels that are connected with the input channel.
            </summary>
            <param name="inputChannelId"></param>
            <param name="outputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.Router.OnChannelMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called wehen the message is received.
            The message is then forwarded to all created connections.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelUnwrapper">
            <summary>
            The interface declares the channel unwrapper.
            The channel unwrapper receives messages from one input channel then unwraps them and forwards to correct input channel. <br/>
            Sequence:
            1. The channel unwrapper receives the message throught its input channel <br/>
            2. The channel unwrapper unwrapps the message and recognizes the channel id where the message shall be forwarded. <br/>
            3. The channel unwrapper forwards the message to the output channel with the unwrapped channel id.<br/>
            4. The messaging system delivers the message to the input channel with the same channel id. <br/>
            5. The receiver listening to the input channel receives the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            The interface declares the API to attach/detach one IDuplexInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel.
            Attaching of the input channel starts the listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            Detaching the input channel stops listening to the messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            If the duplex input channel is attached it means the object that has attached the channel is listening to request messages
            and can send response messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1">
            <summary>
            Event when the typed sequenced response message is received.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the response message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from XmlString.
            The serializer internally uses XmlSerializer provided by .Net.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            The interface declares the API for serialization and deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data to object.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            The serializer internally uses BinaryFormatter provided by .Net.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor">
            <summary>
            The interface declares the fragment processor that is able to process more sequences in parallel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IMultiInstanceFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Implements the thread that processes messages from the message queue.
            When the messages are received the thread calls the callback specified by the user.
            </summary>
            <typeparam name="_MessageType">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor">
            <summary>
            Constructs the working thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.#ctor(System.String)">
            <summary>
            Constructs the working thread with the specified name.
            </summary>
            <param name="workingThreadName">name of the thread</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the callback method handling the messages and starts the 'working thread' processing the
            message queue and calling the callback if the message is received.
            </summary>
            <param name="messageHandler">Callback called from the working thread to process the message</param>
            <exception cref="T:System.InvalidOperationException">Thrown when the message handler is already registered.</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the message callback message handler and releases the thread.
            If the thread does not stop within 5 seconds it is aborted.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Puts the message to the queue.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.Worker">
            <summary>
            Worker method cycling to take messages from the queue and calling the registered handler to process them.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.myMessageHandler">
            <summary>
            Handler called to process the message from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory">
            <summary>
            Implements the factory to create the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory">
            <summary>
            The interface declares the factory creating the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DispatcherFactory.CreateDispatcher">
            <summary>
            Creates the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDispatcher">
            <summary>
            The interface declares the factory to create the dispatcher.
            The dispatcher receives messages via attached input channels and forwards them to all attached output channels.
            (It multiplies the message.)
            <br/>
            Sequence:
            1. A message is received from some attached input channel.
            2. The dispatcher forwards the message into all attached output channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.Dispatcher.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when a message is received from an input channel.
            The message is then sent to all attached output channels.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            The interface declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates the channel wrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the channel unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            The interface declares the broker client.
            The broker client can send messages to the broker (via attached duplex output channel)
            and can subscribe for messages it wants to be notified.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            The interface declares the API to attach/detach one IDuplexOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel.
            When the duplex output channel is attached it can send messages and it also listens to response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the duplex output channel is attached.
            If the duplex output channel is attached it means the object that has attached the channel
            can send the request messages and is listening to response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message of the specified type to the broker.
            If the message is not a simple type then the input parameter expects the message is already serialized!
            </summary>
            <param name="messageTypeId">message type id</param>
            <param name="serializedMessage">
            message content. If the message is not a simple type then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes the client for the message.
            </summary>
            <param name="messageType">message type the client wants to observe</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes the client for messages.
            </summary>
            <param name="messageTypes">list of message types the client wants to observe</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the client from the specified message.
            </summary>
            <param name="messageType">message type the client does not want to observe anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes the client from specified messages.
            </summary>
            <param name="messageTypes">list of message types the client does not want to observe anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Unsubscribes the client from all messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed message is received from the broker.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            The message from broker received event data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages via Tcp. <br/>
            It creates output and input channels using Tcp. <br/>
            The channel id must be a valid Uri address representing an Ip address (e.g. 127.0.0.1:8091).
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            The interface declares the factory that creates input and output channels.
            This factory interface is supposed to be implemented by particular messaging systems so that
            a custom implementation for input and output channels can be provided.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel with defined channel id.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel listening to the specified channel id.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the specified channel id.
            The duplex output channel can receive response messages from the duplex input channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to the specified channel id.
            The duplex input channel can send response messages back to the duplex output channel.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory. The Silverlight version sets the timeout for sending of messages to 30s.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            This constructor is available only in Silverlight and allows to set the timeout for sending of messages.
            </summary>
            <param name="sendMessageTimeout"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel.
            </summary>
            <param name="channelId">Valid Ip address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel. <br/>
            <b>The Tcp input channel is not supported in Silverlight.</b>
            </summary>
            <param name="channelId">Valid Ip (e.g. 127.0.0.1:8090) the input channel will listen to.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel.
            </summary>
            <param name="channelId">Valid Ip address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.TcpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel. <br/>
            <b>The Tcp duplex input channel is not supported in Silverlight.</b>
            </summary>
            <param name="channelId">Valid Ip (e.g. 127.0.0.1:8090) the input channel will listen to.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            The interface declares the API for the duplex output channel.
            The duplex output channel is able to send messages and also receive responses.
            (both-directional communication)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens connection with the duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes connection with the duplex input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the id of the duplex input channel where messages are sent.
            (It represents the address where messages are sent.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns id of the response receiver of this duplex output channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel">
            <summary>
            The interface declares the API for the output channel.
            The output channel is able to send messages. (one-way communication)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IOutputChannel.ChannelId">
            <summary>
            Returns the id of the input channel where messages are sent.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            The namespace contains interfaces that are implemented by components that are able to attach output and 
            input channels (including duplex channels).
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            The event when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            The event when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Declares the event type when the request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer">
            <summary>
            Provides functionality to read and write specific messages internaly used by duplex channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.ReadMessage(System.IO.Stream)">
            <summary>
            Reads the message from the stream.
            </summary>
            <param name="readingStream">stream to be read</param>
            <returns>message</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteMessage(System.IO.Stream,System.Object)">
            <summary>
            Writes the message to the specified stream.
            </summary>
            <param name="writingStream"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteOpenConnectionMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by duplex output channels to open connection with the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsOpenConnectionMessage(System.Object)">
            <summary>
            Returns true if the given message is the open connection message used by the duplex output channel
            to open connection.
            </summary>
            <param name="message">Message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteCloseConnectionMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by the duplex output channel to close the connection with the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsCloseConnectionMessage(System.Object)">
            <summary>
            Returns true if the given message is the message used by the duplex output channel to close
            the connection.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WriteRequestMessage(System.IO.Stream,System.String,System.Object)">
            <summary>
            Writes the request message used by the duplex output channel to send to the duplex input channel.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
            <param name="message">Request message.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsRequestMessage(System.Object)">
            <summary>
            Returns true if the given message is the request message used by the duplex output channel to send
            a message to the duplex input channel.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.WritePollResponseMessage(System.IO.Stream,System.String)">
            <summary>
            Writes the message used by the duplex output channel to poll response messages from the
            duplex input channel. The message is used in case of Http messaging.
            </summary>
            <param name="writingStream">Stream where the message is written.</param>
            <param name="responseReceiverId">Id of receiver of response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.MessageStreamer.IsPollResponseMessage(System.Object)">
            <summary>
            Returns true if the given message is the essage used by the duplex output channel to poll
            messages from the duplex input channel. (in case of Http)
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory to create duplex router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            The interface declares the factory to create duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            The interface declares the broker.
            The broker receives messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase">
            <summary>
            Internal interface for implementing message systems.
            Note: This is just a helper interface helping implementation of some messaging system.
                  It is not mandatory to use this interface to implement the messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="channelId">channel id receiving the message</param>
            <param name="message">message to be sent</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the listener.
            </summary>
            <param name="channelId">channel id registering for receiving messages</param>
            <param name="messageHandler">method handling the incoming message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingSystemBase.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the listener.
            </summary>
            <param name="channelId">channel id to be unregistered from listening</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transferring messages between silverlight applications.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalSenderReceiverFactory">
            <summary>
            The class implements the factory used for the testing purposes when you need to emulate
            silverlight messaging. E.g. when you test with NUnit the main silverlight thread is not available.
            Therefore the messaging will not work and you may want to mock it.
            This factory uses SynchronousMessagingSystemFactory to emulate silverlight messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalSenderReceiverFactory">
            <summary>
            The factory interface declaring methods to create silverlight LocalMessageSender and LocalMessageReceiver.
            Providing the factory interface allows to mock the real silverlight messaging for the testing purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalSenderReceiverFactory.CreateLocalMessageSender(System.String)">
            <summary>
            Creates LocalMessageSender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalSenderReceiverFactory.CreateLocalMessageReceiver(System.String)">
            <summary>
            Creates LocalMessageReceiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalSenderReceiverFactory.#ctor">
            <summary>
            Constructs the factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalSenderReceiverFactory.CreateLocalMessageSender(System.String)">
            <summary>
            Creates mock of the LocalMessageSender based on the SynchronousMessagingSystemFactory.
            </summary>
            <param name="receiverName">silverlight receiver identifier</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalSenderReceiverFactory.CreateLocalMessageReceiver(System.String)">
            <summary>
            Creates mock of the LocalMessageReceiver based on the SynchronousMessagingSystemFactory.
            </summary>
            <param name="receiverName">silverlight receiver identifier</param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages between Silverlight applications.
            It creates output and input channels using the Silverlight messaging.
            The messaging allows to send messages of unlimited size and from any thread. The input channels receive
            messages always in the Silverlight thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalSenderReceiverFactory)">
            <summary>
            The constructor allowing to mock real silverlight messaging.
            The constructor can be used for unit-test purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel.
            </summary>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel.
            </summary>
            <param name="channelId"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageReceiver">
            <summary>
            Interface declares methods so that the silverlight LocalMessageReceiver can be wrapped.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageReceiver.Listen">
            <summary>
            Starts listening from the silverlight messaging system.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageReceiver.MessageReceived">
            <summary>
            Event is invoked when the message is received from the input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageReceiver.ReceiverName">
            <summary>
            Returns the receiver name. The receiver name represents the channel id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive a sequence of strongly typed messages.
            It is guaranteed that the messages will be received in the correct order (same order as sent).<br/>
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1">
            <summary>
            The interface declares the typed message receiver that receives the sequence of messages.
            It is guaranteed the received sequence has the same order as was sent.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message (as a fragment of the sequence) is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when the typed message has received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            The interface declares the duplex string message sender.
            The duplex sender is able to send text messages and receive text responses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the message via the attached duplex output channel.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is invoked when a response message from duplex string message receiver was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1">
            <summary>
            Implements the data fragment for specified data type.
            </summary>
            <typeparam name="_DataType">data type contained in the fragment</typeparam>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.Fragment">
            <summary>
            Provides the basic implementation for IFragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragment">
            <summary>
            The interface declares the fragment.
            Fragments are used to sequence data.
            The fragment contains the SequenceId identifying the sequence where the fragment blongs, Index specifying the position in the sequence
            and IsFinal indicating if it is the last fragment of the sequence.<br/>
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.SequenceId">
            <summary>
            Returns identifier of the sequence where the fragment belongs.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragment.IsFinal">
            <summary>
            Returns true if it is the last fragment in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.Fragment.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from the input parameters.
            </summary>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Position in the sequence.</param>
            <param name="isFinal">Indicates whether it is the last fragment.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.Index">
            <summary>
            Returns the position of the fragment in the sequence.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.Fragment.IsFinal">
            <summary>
            Returns true if the item is the last in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor">
            <summary>
            Default constructor used for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from parameters.
            </summary>
            <param name="data">Data contained in the fragment.</param>
            <param name="sequenceId">Identifies the sequence where the fragment belongs.</param>
            <param name="index">Number of the fragment.</param>
            <param name="isFinal">Indicates whether the fragmant is the last one.</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.DataFragment`1.Data">
            <summary>
            Data contained in the fragment.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            The interface declares the factory to create the duplex dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel">
            <summary>
            Internal basic implementation of the input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel">
            <summary>
            The interface declares the API for the input channel.
            The input channel is able to receive messages. (one-way communication)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StartListening">
            <summary>
            Starts listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.StopListening">
            <summary>
            Stops listening.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.ChannelId">
            <summary>
            Returns id of the channel.
            The channel id represents the address the receiver is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IInputChannel.IsListening">
            <summary>
            Returns true if the input channel is listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StartListening">
            <summary>
            Registers the delegate in the messaging system to receive messages from a desired channel id and starts the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.StopListening">
            <summary>
            Unregisters the channel id from the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleInputChannel.HandleMessage(System.Object)">
            <summary>
            Handles the received message from the message system.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId">
            <summary>
            Represents the message that contains the sender id too.
            It is used for request-response messaging where the sender id is used by the message
            receiver to send back the response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId.SenderId">
            <summary>
            Id of the message sender. The message receiver can use the sender id to send back the response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageWithResponseReceiverId.Message">
            <summary>
            The content of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transferring messages via Http.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            The interface declares the API to attach/detach multiple IDuplexInputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches all duplex input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.StopListeningDuplexInputChannel(Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext)">
            <summary>
            It stops listening to the duplex input channel and closes connections in all associated duplex
            output channels.
            Note: The method should not throw any exception.
            </summary>
            <param name="duplexInputChannelContext"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1">
            <summary>
            Data used for the typed sequenced message fragment.
            The data is used to send the message fragment from a duplex output channel to a duplex input receiver.
            </summary>
            <typeparam name="_RequestType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            The interface declares the duplex strongly typed message sender.
            The duplex sender is able to send messages of the specified type and receive responses of the specified type.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the strongly typed message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver">
            <summary>
            The interface declares the string message receiver.
            The receiver is able to receive text messages via one-way input channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IStringMessageReceiver.MessageReceived">
            <summary>
            The event is invoked when a string message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from an xml string.
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory">
            <summary>
            The factory class provides methods to create fragment processors.
            The fragment processors provides strategies to process incoming fragments of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateFragmentSequencer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and continuously returns the sequence of ordered fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateSequenceFinalizer(System.String)">
            <summary>
            Creates the fragment processor ordering the incoming sequence of fragments.
            The sequencer receives data fragments and when the whole sequence is collected it returns it.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentDataFactory.CreateMultiinstanceFragmentProcessor(System.Func{System.String,Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor})">
            <summary>
            Creates the fragment processor able to process more sequences at once.
            </summary>
            <param name="fragmentProcessorFactoryMethod">
            Factory method used to create processors for particular sequences.
            Note: CreateFragmentSequencer() and CreateSequenceFinalizer() from this factory class can be used as factory methods.
            </param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for queuing messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1">
            <summary>
            The message fragment for the specified message type.
            The message fragment wrapps the specified message type so that it can be sent as a part of a sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender">
            <summary>
            The interface declares the string message sender.
            The sender is able to send text messages via one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the string message via the attached output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs">
            <summary>
            The string message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringMessageEventArgs.Message">
            <summary>
            Returns the received string message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandContext`2">
            <summary>
            The interface represents the context of the particular command execution.
            It is passed as the input parameter to the method performing the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until the input data fragment is received.<br/>
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <returns>data fragment wrapping the input data</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.DequeueInputData(System.Int32)">
            <summary>
            Returns the input data for the command.
            The command proxy has a possibility to send the input data as a sequence. Therefore the input data coming in
            fragments are put to the queue, from where they can be removed by this method.
            If the queue is empty the calling thread is blocked until
            the input data fragment is received or the specified timeout occured.
            Note: The parameter index in DataFragment is not used and is set to -1.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time for the input data. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>data fragment wrapping the input data</returns>
            <exception cref="T:System.TimeoutException">when the maximum waiting time for the input data is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause">
            <summary>
            If the pause is the current request then it blocks the calling thread until resumed or canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.WaitIfPause(System.Int32)">
            <summary>
            If the pause is requested then it blocks the calling thread until resumed or canceled.
            </summary>
            <param name="millisecondsTimeout">maximum waiting time in miliseconds</param>
            <returns>true if the timeout did not occur</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponsePause">
            <summary>
            Notifies the command proxy that the command was paused.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseCancel">
            <summary>
            Notifies the command proxy that the command was canceled.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.ResponseFailure(System.String)">
            <summary>
            Notifies the command proxy that the command failed.
            </summary>
            <param name="errorMessage">error message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0)">
            <summary>
            Sends the return data to the command proxy.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.Response(Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean)">
            <summary>
            Sends the return data to the command proxy.
            The method can be used if the return data is sent in more fragments.
            E.g. If the command wants to notify progress or some partial results.
            </summary>
            <param name="commandState">command state</param>
            <param name="returnData">return data</param>
            <param name="sequenceId">identifies the sequence where the fragment of return data belongs</param>
            <param name="isReturnDataSequenceCompleted">true if this is the last fragment of the sequence</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandProxyId">
            <summary>
            Returns identifier of the command proxy that executed this command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CommandId">
            <summary>
            Returns identifier of this command. (If one command proxy executes more commands they can be recognized with this id.)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.NumberOfInputData">
            <summary>
            Returns number of input data in the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.CurrentRequest">
            <summary>
            The currently set request for the command e.g. Pause, Resume or Cancel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.ICommandContext`2.IsCommandProxyConnected">
            <summary>
            Returns true if the command proxy that executed the command is still connected.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for serialization and deserialiazation of data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            The namespace contains the functionality to work with the Broker.
            The Broker receives messages and forwards them to subscribed receivers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages synchronously in the caller thread.
            It creates output and input channels using the caller thread to deliver messages.
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommand`2">
            <summary>
            The interface declares the command.
            The command is able to receive requests with strongly typed input data.
            The commant can also be paused, resumed or canceled.
            The response return strongly typed return data and the status of the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.ErrorReceived">
            <summary>
            The event is invoked when an error was detected during receiving the request. (e.g. a deserialization error)
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommand`2.CommandProxyDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2">
            <summary>
            The interface declares the command proxy.
            The command proxy is able to send the request to execute some activity in the respective command.
            The command proxy is also able to request pause, resume or cancel.
            It receive response messages from the command.
            </summary>
            <typeparam name="_ReturnDataType"></typeparam>
            <typeparam name="_InputDataType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Pause(System.String)">
            <summary>
            Sends the pause request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Resume(System.String)">
            <summary>
            Sends the resume request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Cancel(System.String)">
            <summary>
            Sends the cancel request to the command.
            </summary>
            <param name="commandId">identifies the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1)">
            <summary>
            Sends the execute request to the command.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.Execute(System.String,`1,System.String,System.Boolean)">
            <summary>
            Sends the execute request to the command.
            The input data is sent as a sequence.
            </summary>
            <param name="commandId">identifies particular command e.g. when the proxy invokes more commands</param>
            <param name="inputData">input data</param>
            <param name="sequenceId">input data sequence identifier</param>
            <param name="isSequenceCompleted">true - if the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Commands.ICommandProxy`2.CommandResponseReceived">
            <summary>
            The event is invoked when the response message from the command was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.MultiInstanceFragmentProcessor">
            <summary>
            Implements the fragment processor able to process more sequences of fragments in parallel.
            It creates the fragment processor (IFragmentProcessor) for each sequence.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor">
            <summary>
            The interface declares the fragment processor.
            The fragment processor is used to process incoming fragments. Fragment processors can implement
            various strategies how to process fragments.<br/>
            The fragment processor is intended to process one sequence of fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            Processes the fragment and returns the sequence of processed fragments ready for the user.
            If the processing of the fragment do not result in a sequence for the user it can return the empty sequence.<br/>
            
            E.g.: It can happen the fragments of the sequence do not come in the right order. Therefore the processing
                  can hold such fragments and return the empty sequence. Then later when it is possible to return
                  fragments in the correct order the processing can return the sequence with fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.SequenceId">
            <summary>
            Returns the sequence identifier processing by the fragment processor.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.IFragmentProcessor.IsWholeSequenceProcessed">
            <summary>
            Returns true if the whole sequence is processed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentSequencer.#ctor(System.String)">
            <summary>
            The constructor initializes the sequencer for a particular instance.
            </summary>
            <param name="sequenceId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            The factory class implementats the messaging system delivering messages between threads.<br/>
            Each input channel is represented by its own working thread removing messages from its queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be instantiated by the same instance of ThreadMessagingSystemFactory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.TcpMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transferring messages via Tcp.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageSender">
            <summary>
            Interface declares methods so that the silverlight LocalMessageSender can be wrapped.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageSender.SendAsync(System.String)">
            <summary>
            Sends the message to the silverlight messaging.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.ILocalMessageSender.ReceiverName">
            <summary>
            Returns the receiver name. The receiver name represents the channel id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory">
            <summary>
            Implements the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory">
            <summary>
            The interface declares the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connenction provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connection provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider">
            <summary>
            The interface declares methods for convenient attaching of channels and
            for connecting senders and receivers with channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,System.String)">
            <summary>
            Creates and attaches the input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates and attaches the output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates and attaches the duplex output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableOutputChannel,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">Input channel attachable component (receiver)</param>
            <param name="outputComponent">Output channel attachabel component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleOutputChannels,System.String)">
            <summary>
            Creates the input channel and output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">input channel attachable component (receiver)</param>
            <param name="outputComponent">multiple output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.MessagingSystem">
            <summary>
            Returns the messaging system used by the connection provider.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory">
            <summary>
            The interface declares the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory">
            <summary>
            The interface declares the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ICommandsFactory">
            <summary>
            The interface declares the factory to create command proxy and command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.ICommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
             <summary>
             Creates the command.
             </summary>
             <typeparam name="_ReturnDataType">type of return data</typeparam>
             <typeparam name="_InputDataType">type of input data</typeparam>
             <returns>command</returns>
             <example>
             The following example shows how to implement the method performing a command,
             so that the method processes Pause, Resume, Cancel and Failures.
             <code>
             private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
             {
                 try
                 {
                     // Read the input data.
                     DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                     bool anInputData = anInputDataFragment.Data;    
            
                     for (int i = 0; i &lt; 100; ++i)
                     {
                         // Simulate some work.
                         Thread.Sleep(100);
             
                         // Wait if pause is requested.
                         if (commandContext.CurrentRequest == ECommandRequest.Pause)
                         {
                             // Notify the command proxy that the command was paused.
                             commandContext.ResponsePause();
             
                             // Wait until resumed or canceled.
                             commandContext.WaitIfPause();
                         }
             
                         // If the cancel is requested then stop the command.
                         // Note: The check for the cancel is placed after the check for the pause
                         //       because when the command is paused it can be canceled.
                         if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                         {
                             // Notify the command proxy that the command was canceled.
                             commandContext.ResponseCancel();
                             return;
                         }
             
                         // Notify the progress.
                         ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                         commandContext.Response(aState, i + 1);
                     }
                 }
                 catch (Exception err)
                 {
                     commandContext.ResponseFailure(err.Message);
                 }
             }
             </code>
             </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2">
            <summary>
            The interface declares the duplex sender that sends sequences of strongly typed messages.
            The sender is able to send sequences of typed messages and receive sequences of typed response messages.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.SendMessage(`1,System.String,System.Boolean)">
            <summary>
            Sends typed message.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2">
            <summary>
            The interface declares the duplex receiver of sequence of strongly typed messages.
            The receiver is able to receive sequence of messages of specified type and response the sequence of messages
            of specified type. <br/>
            It is guaranteed the sequence is received in the same order as was sent. <br/>
            <b>Note: Be aware that if the 'thread pool messaging system' is chosen the incoming messages
            are processed in more threads in parallel. Therefore the 'thread pool messaging system'
            cannot guarantee the order of incoming messages. <br/>
            Consider to use the 'thread messaging system' instead.
            </b>
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of the receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.SendResponseMessage(System.String,`0,System.String,System.Boolean)">
            <summary>
            Sends the response message to the specified duplex typed sequenced message sender.
            </summary>
            <param name="responseReceiverId">specifies the duplex typed sequenced message sender that will receive the response</param>
            <param name="responseMessage">message</param>
            <param name="sequenceId">identifies the sequence the message is part of</param>
            <param name="isSequenceCompleted">true - indicates the sequence is completed</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender opened connection via duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex typed sequenced message sender closed connection via duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create duplex typed sequenced message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with the binary serializer.
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified serializer.
            </summary>
            <param name="serializer"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageSender``2">
            <summary>
            Creates the duplex typed sequenced message sender.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
            <returns>duplex typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.DuplexTypedSequencedMessagesFactory.CreateDuplexTypedSequencedMessageReceiver``2">
            <summary>
            Creates the duplex typed sequences message receiver.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
            <returns>duplex typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1">
            <summary>
            The typed message received event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the given error message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Implements the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            The interface declares the factory to create duplex strongly typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">Type of sending messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer. <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the method factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender.
            </summary>
            <typeparam name="_ResponseType">Type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">Type of sending messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive simple text messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening.
            </summary>
            <param name="duplexInputChannel"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops the listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.OnMessageReceived(System.Object,Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs{Eneter.Messaging.EndPoints.Commands.CommandInputData{`1}})">
            <summary>
            The method is called when a request is received.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.CommandProcessingAsyncCallback(System.IAsyncResult)">
            <summary>
            The method is called when the asynchronous call to process the command is finished.
            (in case of parallel processing mode)
            </summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.Command`2.WorkingThreadHandler(Eneter.Messaging.EndPoints.Commands.CommandItem{`0,`1})">
            <summary>
            Removes the 'execute command' requests from the queue and execute them.
            The method is used in case of single thread mode.
            </summary>
            <param name="commandContext"></param>
        </member>
        <member name="T:System.Collections.Generic.HashSet`1">
            <summary>
            Represents a set of values.
            </summary>
            <remarks>
            (This is a stripped down Silverlight port of the full .NET CLR's <see cref="T:System.Collections.Generic.HashSet`1" /> class.
            The API is feature complete and compatible
            except for serialization implementations which are not supported by Silverlight.
            Some private methods called in operations with other <see cref="T:System.Collections.Generic.IEnumerable`1" />s
            are not implemented by taking advantage of some unsafe bit-level optimization code
            in certain constellations, but otherwise should work the same.
            This implementation is copied using the Reflector and thus the copyright is fully at Microsoft.
            It will remain here until the HashSet is included in a future version of the Silverlight base class library.)
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Adds the specified element to a set.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; false if the element is already present.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.
            </summary>
            <param name="item">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy to array.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0 -or- count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">arrayIndex is greater than the length of the destination array -or- count is greater than the available space from the index to the end of the destination array.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="other">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <returns>A Enumerator object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object overlaps the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and other share at least one common element; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="item">The element to remove.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if item is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</returns>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in both itself and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Gets the number of elements that are contained in a set.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1">
            <summary>
            The interface declares the typed messsage sender that can send the messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ITypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of the specified type as a fragment of a sequence.
            The sequence identifier is an id for the sequence and must be same for all sent messages belonging to the sequence.
            </summary>
            <param name="message">message fragment</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating whether this is the last fragment of the message and sequence is completed</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageSender`1.SendMessage(`0,System.String,System.Boolean)">
            <summary>
            Sends the message of specified type as a fragment of a sequence.
            </summary>
            <param name="message">typed message</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="isSequenceCompleted">flag indicating if the sequence is completed</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            The namespace contains functionality to send and receive strongly typed messages of specified type.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            The interface declares the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandState">
            <summary>
            Enumerates possible commands states.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotApplicable">
            <summary>
            The state is not applicable.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.NotStarted">
            <summary>
            The command was not executed yet.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.InProgress">
            <summary>
            The execute request is in the progress.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Paused">
            <summary>
            The execute request is paused.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Completed">
            <summary>
            The execute request is completed.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Canceled">
            <summary>
            The execute request is canceled.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandState.Failed">
            <summary>
            The execute request failed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandsFactory">
            <summary>
            Implements the factory to create command proxy and command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor">
            <summary>
            Constructs the factory with binary serializer.
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.IDuplexTypedSequencedMessagesFactory)">
            <summary>
            Constructs the factory with the specified duplex typed sequenced messages factory.
            The duplex typed sequenced messages are used internally by the command (and command proxy) so
            you can provide your own implementation if needed.
            </summary>
            <param name="duplexTypedSequencedMessagesFactory">duplex typed sequenced messages factory</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommandProxy``2">
            <summary>
            Creates the command proxy.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command proxy</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandsFactory.CreateCommand``2(System.Action{Eneter.Messaging.EndPoints.Commands.ICommandContext{``0,``1}},Eneter.Messaging.EndPoints.Commands.EProcessingStrategy)">
            <summary>
            Creates the command.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
            <typeparam name="_InputDataType">type of input data</typeparam>
            <returns>command</returns>
            <example>
            The following example shows how to implement the method performing a command,
            so that the method processes Pause, Resume, Cancel and Failures.
            <code>
            private void CommandProcessingMethod(ICommandContext&lt;int, bool&gt; commandContext)
            {
                try
                {
                    // Read the input data.
                    DataFragment&lt;bool&gt; anInputDataFragment = commandContext.DequeueInputData();
                    bool anInputData = anInputDataFragment.Data;    
            
                    for (int i = 0; i &lt; 100; ++i)
                    {
                        // Simulate some work.
                        Thread.Sleep(100);
            
                        // Wait if pause is requested.
                        if (commandContext.CurrentRequest == ECommandRequest.Pause)
                        {
                            // Notify the command proxy that the command was paused.
                            commandContext.ResponsePause();
            
                            // Wait until resumed or canceled.
                            commandContext.WaitIfPause();
                        }
            
                        // If the cancel is requested then stop the command.
                        // Note: The check for the cancel is placed after the check for the pause
                        //       because when the command is paused it can be canceled.
                        if (commandContext.CurrentRequest == ECommandRequest.Cancel)
                        {
                            // Notify the command proxy that the command was canceled.
                            commandContext.ResponseCancel();
                            return;
                        }
            
                        // Notify the progress.
                        ECommandState aState = (i == 99) ? ECommandState.Completed : ECommandState.InProgress;
                        commandContext.Response(aState, i + 1);
                    }
                }
                catch (Exception err)
                {
                    commandContext.ResponseFailure(err.Message);
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandInputData`1">
            <summary>
            The class is used by the eneter framework to transfer a request to the command.
            </summary>
            <typeparam name="_InputDataType">type of input data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor">
            <summary>
            Default constructor for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandRequest,`0)">
            <summary>
            Constructs from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="request">type of the request</param>
            <param name="inputData">input data</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.InputData">
            <summary>
            Input data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandInputData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            The namespace contains functionality for diagnostic (tracing and debugging) purposes.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Puts the added data on "top" of original data. It creates the structure WrappedData and
            serializes it with the given serializer.
            </summary>
            <param name="addedData">added data</param>
            <param name="originalData">original data</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer">
            <summary>
            The class collects and sorts incoming fragments.
            When all fragments are collected the ProcessFragment method returns the fragment of sorted fragments.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.#ctor(System.String)">
            <summary>
            The constructor initializes the finalizer for the given instance id.
            </summary>
            <param name="sequenceId">sequence that the finalizer processes</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.ProcessFragment(Eneter.Messaging.DataProcessing.Sequencing.IFragment)">
            <summary>
            The method puts incoming fragment to the sequenece.
            It returns the collection when all fragments are collected and sorted.
            </summary>
            <param name="fragment"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.mySortedFragments">
            <summary>
            The collection collects ordered fragments.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.SequenceId">
            <summary>
            Returns the instance id.
            The instance id specifies which fragments belong together.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.IsWholeSequenceProcessed">
            <summary>
            Returns true if all fragments have been processed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Sequencing.FragmentFinalizer.FragmentSequencer">
            <summary>
            The sequencer for sequencing of fragments.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            The namespace contains the functionality to work with the router.
            The router receives messages from attached input channels and forwards them to configured
            output channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IRouterFactory">
            <summary>
            The interface declares the factory creating the router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IRouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            The interface declares the duplex dispatcher.
            The duplex dispatcher receives messages from attached input channels and forwards them to all
            duplex output channels.<br/>
            The using of duplex channels enables to send back response messages (from all receivers).
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Implements the factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelWrapper">
            <summary>
            Creates channel wrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates channel unwrapper.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            The event data representing the response receiver id.
            The event is used for the communication between the duplex output channel and duplex input channel
            to identify where to send response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
            <param name="responseReceiverId">identifies the response message receiver</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns response message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            The event data available when the duplex input channel receives a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">channel identifier</param>
            <param name="message">message</param>
            <param name="responseReceiverId">identifies the client receiving response messages</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.ChannelId">
            <summary>
            Returns the channel identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.ResponseReceiverId">
            <summary>
            Returns the identifier of the response receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1">
            <summary>
            The interface declares the strongly typed message receiver.
            The receiver is able to receive messages of the specified type via one-way input channel.
            </summary>
            <typeparam name="_MessageDataType">
            Type of the message.
            </typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is invoked when a typed message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            The interface declares the duplex strongly typed message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message back to the duplex typed message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex typed message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message from a duplex typed message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            The event when a string response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transfering messages with using .Net thread pool.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightInputChannel.Dispose">
            <summary>
            Explicit dispose called by a user.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightInputChannel.Dispose(System.Boolean)">
            <summary>
            Method disposing managed and unmanaged resources.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightInputChannel.Finalize">
            <summary>
            Finalizer called by the garbage collector.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightInputChannel.OnEneterMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method processes the incomming message.
            When the message is received it recognizes if it is a simple message or a split message.
            The simple message is directly notified.
            The split message is stored in the collector and is notified when the whole message is collected.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightInputChannel.myLocalMessageReceiver">
            <summary>
            Sirvelight's message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1">
            <summary>
            The event when the typed sequenced message is received.
            </summary>
            <typeparam name="_MessageDataType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="receivingError">error detected during receiving of the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.MessageData">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessageReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory">
            <summary>
            Implements the factory to create strongly typed message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor">
            <summary>
            Constructs the typed messages factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b> 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageSender``1">
            <summary>
            Creates the typed message sender.
            The sender sends the messages via attached one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessagesFactory.CreateTypedMessageReceiver``1">
            <summary>
            Creates the typed message receiver.
            The receiver receives messages via attached one-way input channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory">
            <summary>
            The interface declares the factory to create string message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageSender">
            <summary>
            Creates the string message sender.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringMessagesFactory.CreateStringMessageReceiver">
            <summary>
            Creates the string message receiver.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            The interface declares the duplex string message receiver.
            The duplex receiver is able to receive text messages and send text responses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the duplex string message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message from the duplex string message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex string message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex string message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            The class provides the functionality to trace info, warning and error messages.
            The trace displays the time, thread id and the message for every trace entry.
            The messages can be observed on the debug port.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message">information message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.String)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.String)">
            <summary>
            Traces the error message and details for the error.
            </summary>
            <param name="message">error message</param>
            <param name="errorDetails">error details</param>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Sequencing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality to sequence data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue">
            <summary>
            Implements the message queue.
            One or more threads can put messages to the queue and other threads
            can remove messages from the queue to process them.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.EnqueueMessage(System.Object)">
            <summary>
            Puts messages to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked.
            To unblock threads waiting here use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage().
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            The interface declares the factory creating the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages and receive notifications from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            The broker can receive messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transfering messages between threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.SimpleOutputChannel">
            <summary>
            Internal basic implementation for the output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            The interface declares the API for the duplex input channel.
            The duplex input channel is able to receive messages and also send response messages back to the sender.
            (both-directional communication)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the connected IDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId">Identifies the response receiver. The identifier comes with received messages.</param>
            <param name="message">response message</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex output channel closed the connection.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns id of this duplex input channel.
            The id represents the 'address' the duplex input channel is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.ServerUri">
            <summary>
            Helper class used in Silverlight environment to get the valid Uri for the hosting server.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.ServerUri.GetServerUri(System.String)">
            <summary>
            Returns the Uri string for the given path on the hosting server.
            </summary>
            <param name="pathToHandlerInAsp">path to the message handler (ashx file)</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy">
            <summary>
            Lists possibilities how the command will process requests for execution.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.SingleThread">
            <summary>
            All requests to execute the command are queued and processed by one thread.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.EProcessingStrategy.MultiThread">
            <summary>
            All requests to execute the command are executed immediately in separate threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs">
            <summary>
            Event data when a request was received in the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="commandId">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandProxyId">
            <summary>
            Gets the identifier of the command proxy that sent the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandRequestEventArgs.CommandId">
            <summary>
            Gets command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for writing and reading messages from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            The namespace contains the functionality to work with the dispatcher.
            The dispatcher receives messages and forwards them to all attached receivers. (it multiplies the message)
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            The interface declares the duplex channel wrapper.
            The duplex channel wrapper receives the messages from senders then wrapps them and sends them
            to the output channel.
            It is supposed the receiving side has the corresponding unwrapper to unwrap messages and send them
            to correct receivers.
            The using of the duplex channels enables senders to receive response messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            The namespace contains the messaging system transfering messages synchronously in the caller thread.
            Therefore the sender is blocked until the message is not delivered and processed.
            This is a fast messaging suitable to transfer messages between local components if the synchronous
            approach is desired or the synchronous approach is not a problem.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.#ctor(System.String,System.Int32)">
            <summary>
            Constructs Http duplex output channel.
            The Http duplex output channel can send messages and receive responses from Http duplex input channel.
            </summary>
            <param name="channelId">Uri address of Http duplex input channel.</param>
            <param name="pollingFrequencyMiliseconds">How often the pulling for response messages will occur.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.OpenConnection">
            <summary>
            Starts pulling for response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.CloseConnection">
            <summary>
            Stops pulling for response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.HandleResponseMessage(System.Object)">
            <summary>
            Handles response messages from the queue.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.ChannelId">
            <summary>
            Returns the channel id. - the channel id is Uri.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the connection is open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageReceiver`1.MessageReceived">
            <summary>
            The event is rised when the message is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Wrapping.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            The namespace contains the functionality to work with channel wrapper and channel unwrapper.
            The channel wrapper and channel unwrapper helps to minimize number of channels used for the communication.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapper">
            <summary>
            The interface declares the channel wrapper.
            The channel wrapper receives the messages from senders then wrapps them and sends them to one output channel.
            It is supposed the receiving side has the corresponding unwrapper to unwrap messages and send them
            to correct receivers.<br/>
            Sequence:
            1. The sender sends the message through its output channel. <br/>
            2. The messaging system delivers the message to the input channel with the same channel id. <br/>
            3. The channel wrapper listening to that input channel receives the message then wrapps it and sends
               it to its output channel. (note: it has only one output channel)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelUnwrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel unwrapper receives a messae to be unwrapped and sent to the
            correct output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1">
            <summary>
            The event when a typed sequenced message is received.
            </summary>
            <typeparam name="_RequestType">The type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.TypedSequencedMessages.RequestMessageFragment{`0})">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="dataFragment">message fragment</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response message can be sent</param>
            <param name="receivingError">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.SequenceId">
            <summary>
            Returns the sequence identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true if the sequence is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns message inputData of the specified type.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            E.g. during the deserialization of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1">
            <summary>
            Data used for the typed sequenced response message fragment.
            The data is used to send response message from a duplex input channel to a duplex output channel.
            </summary>
            <typeparam name="_ResponseType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor">
            <summary>
            Default constructor for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.#ctor(`0,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructor creating the typed message fragment from the given input parameters.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedSequencedMessages.ResponseMessageFragment`1.FragmentData">
            <summary>
            Returns serialized fragment value.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1">
            <summary>
            The interface declares the typed messsage sender.
            The sender is able to send messages of the specified type via one-way output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ITypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends the message of specified type via IOutputChannel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedMessageSender`1.SendMessage(`0)">
            <summary>
            Sends message via the output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1">
            <summary>
            Event data when the response from the command was received.
            </summary>
            <typeparam name="_ReturnDataType">type of return data</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String,System.Boolean,System.String)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="commandState">state of the command</param>
            <param name="returnData">return data coming from the command</param>
            <param name="sequenceId">return data sequence id</param>
            <param name="isSequenceCompleted">tru - if the sequence of return data is completed</param>
            <param name="commandError">error message coming from the command</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event data when an error was detected during receiving the response.
            (e.g. a deserialization error)
            </summary>
            <param name="receivingError"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandState">
            <summary>
            Gets command state.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReturnData">
            <summary>
            Gets return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.SequenceId">
            <summary>
            Gets the sequence is of return data from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.IsSequenceCompleted">
            <summary>
            Returns true - if the sequence of return data is completed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an error detected during receiving the response. (e.g. deserialization error)
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandError">
            <summary>
            Returns an error message coming from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandResponseReceivedEventArgs`1.CommandId">
            <summary>
            Returns command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            The interface declares the duplex router.
            The duplex router receives messages from attached input channels and forwards them to configured
            output channels. <br/>
            The using of duplex channels enables sending of response messages from all receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs)">
            <summary>
            The method is called when the channel wrapper receives a message from one of input channels.
            It wrapps the message and sends it to the output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Implents the factory creating broker and broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages and receive notifications from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            The broker can receive messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the broker request.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            The request is to subscribe to observe messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            The request is to unsubscribe from the observation.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage">
            <summary>
            The class represents the data structure used to send requests to the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor">
            <summary>
            Default constructor used for serialization/deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Creates the request from input parameters.
            </summary>
            <param name="request"></param>
            <param name="messageTypes"></param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.Request">
            <summary>
            Returns type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerRequestMessage.MessageTypes">
            <summary>
            Returns the array of message types.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage">
            <summary>
            The data representing the message sent to the broker to notify subscribed clients.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the message data from the input parameters.
            </summary>
            <param name="messageTypeId">Type of the notified message.</param>
            <param name="message">Message content.</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.MessageTypeId">
            <summary>
            Type of the notified message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerNotifyMessage.Message">
            <summary>
            Message content.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightFragmentMessage">
            <summary>
            The original silverlight messages have the size restriction. The eneter framework overcomes that
            by fragmenting longer messages. This data structure is used to transfer the fragment of silverlight message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightFragmentMessage.#ctor">
            <summary>
            Default constructor for deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightFragmentMessage.#ctor(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Constructs the fragment from input parameters.
            </summary>
            <param name="message">message</param>
            <param name="sequenceId">sequence identifier</param>
            <param name="index">number of the fragment</param>
            <param name="isFinal">indicates whether it is the last segment</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.SilverlightFragmentMessage.Message">
            <summary>
            Message fragment content.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs">
            <summary>
            The event data available when the input channel receives a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event data from the input parameters.
            </summary>
            <param name="channelId">channel identifier</param>
            <param name="message">message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.ChannelId">
            <summary>
            Returns the channel identifier.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.NamespaceDoc">
            <summary>
            The namespace contains functionality to connect components with channels.<br/>
            The connector provider is a helper reducing amount of coding needed to create and attach channels
            to connect components.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.ECommandRequest">
            <summary>
            Enumerates requests the command can receive.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Execute">
            <summary>
            The command is asked to execute the activity.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Pause">
            <summary>
            The command is asked to pause.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Resume">
            <summary>
            The command is asked to resume.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.Commands.ECommandRequest.Cancel">
            <summary>
            The command is asked to cancel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Wrapping.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for wrapping and unwrapping serialized data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            The interface declares the duplex channel unwrapper.
            The duplex unwrapper receives messages from one duplex input channel then unwraps them
            and forwards into the correct receiver (via duplex output channel).
            The using of the duplex channels enables receivers to send back response messages.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opend the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages with using .Net thread pool.
            The messages are put to the queue of .Net thread pool. The receiving input channel is then called
            in the context of the thread from the pool. Therefore the input channel can process more messages at once
            and also can notify the subscriber from more different threads at the same time. <br/>
            <b>Therefore do not forget to be careful and avoid race conditioning.</b>
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creagtes the output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel.
            The input channel will receive messages in a thread from a .Net trhead pool.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel.
            </summary>
            <param name="channelId">identifies the receiver</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel.
            The duplex input channel will receive messages in a thread from a .Net trhead pool.
            </summary>
            <param name="channelId">receiver id</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            The namespace contains interfaces declaring input and output channels and messaging system factory.
            <br/>
            The messaging system is a system responsible for delivering messages from a sender to a receiver.
            The messaging system can transfer messages through different boundaries and can be based on various technologies.
            E.g. messaging systems transfering messages among threads, processes or computers or silverlight applications.
            <br/>
            The idea of interfaces in this namespace is to provide a unified approach for all messaging systems.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1">
            <summary>
            The class is used by the eneter framework to transfer command return data.
            </summary>
            <typeparam name="_ReturnDataType">type of return data from the command</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor">
            <summary>
            Default constructor for deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.#ctor(System.String,Eneter.Messaging.EndPoints.Commands.ECommandState,`0,System.String)">
            <summary>
            Constructs the class from the input parameters.
            </summary>
            <param name="commandId">command identifier</param>
            <param name="state">command state</param>
            <param name="returnData">return data</param>
            <param name="errorMessage">command identifier</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandState">
            <summary>
            State of the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ReturnData">
            <summary>
            Return data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.ErrorMessage">
            <summary>
            Error message from the command.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReturnData`1.CommandId">
            <summary>
            Command identifier.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs">
            <summary>
            Event data when an error was detected during receiving a request in the command.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.#ctor(System.String,System.Exception)">
            <summary>
            Constructs the event data.
            </summary>
            <param name="commandProxyId">identifier of the command proxy that sent the request</param>
            <param name="receivingError">error detected during receiving the request (e.g. deserialization error)</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.Commands.CommandReceivingErrorEventArgs.ReceivingError">
            <summary>
            Gets error detected during receiving the request (e.g. deserialization error)
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.RouterFactory">
            <summary>
            Implements the factory creating the router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.RouterFactory.CreateRouter">
            <summary>
            Creates the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements the factory to create the duplex dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalMessageSender">
            <summary>
            Testing mock for easy replacing of real silverlight LocalMessageSender during unit testing.
            E.g. if you want to perform tests with NUnit the silverlight main thread is not available.
            Therefore you can provide here some other messaging e.g. synchronous messaging or thread messaging.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalMessageSender.#ctor(System.String,Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the testing mock from input parameters.
            </summary>
            <param name="receiverName">Receiver identifier in silverlight.</param>
            <param name="messagingSystemFactory">Messaging that will replace the silverlight messaging</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalMessageSender.SendAsync(System.String)">
            <summary>
            Sends the message as if from original silverlight LocalMessageSender.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SilverlightMessagingSystem.TestingLocalMessageSender.ReceiverName">
            <summary>
            Receiver identifier in silverlight.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages via Http. <br/>
            It creates output and input channels using Http. <br/>
            The channel id must be a valid Uri address (e.g. 127.0.0.1:8091). Also it must be ensured the listener has enough access rights
            for listening Http requests. (e.g. when you start the listener you can execute it under administrator rights)
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channel with default settings. The polling
            frequency is 500 ms and the inactivity timeout is 30000 ms.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            Constructs the HttpMessagingFactory that will create channel with specified settings.
            </summary>
            <param name="pollingFrequency">polling for response messages frequency in ms.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateOutputChannel(System.String)">
            <summary>
            Creates the output channel. The channel id must be a valid Uri address.
            </summary>
            <param name="channelId">Valid Uri address of the receiver.</param>
            <returns>output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateInputChannel(System.String)">
            <summary>
            Creates the input channel. The channel id must be a valid Uri address the input channel will listen to.
            Note: Do not forget to ensure the listener has enough access rights for listening.<br/>
            <b>The Http input channel is not supported in Silverlight.</b>
            </summary>
            <param name="channelId">Valid Uri address the input channel will listen to.</param>
            <returns>input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel with the specified id. The channel id must be a valid Uri address.
            </summary>
            <param name="channelId">channel id specifying the address of the listening Http server.
            The id must be a valid Uri address.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel with the specified id. The channel id must be a valid Uri address.<br/>
            <b>The Http duplex input channel is not supported in Silverlight.</b>
            </summary>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory">
            <summary>
            Implements the factory to create senders and receivers of sequence of typed messages.
            The senders and receivers ensure the correct order of messages in the sequence.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor">
            <summary>
            Constructs the sequences typed messages factory with BinarySerializer.
            <br/>
            <b>Note: The serializer is XmlStringSerializer in case of Silverlight.</b> 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the sequenced typed message factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageSender``1">
            <summary>
            Creates the sender of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedSequencedMessages.TypedSequencedMessagesFactory.CreateTypedSequencedMessageReceiver``1">
            <summary>
            Creates the receiver of messages of specified type.
            </summary>
            <typeparam name="_MessageDataType">The type of the message.</typeparam>
            <returns>typed sequenced message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            The dynamic stream supports writing of data by one thread and reading by another.
            When the requested amount of data is not available in the stream the reading is blocked
            until the data is available or the stream is closed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available.
            </summary>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            The stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            The stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            The stream supports writing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            The stream does not support length of the stream.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            The position is not applicable.
            </summary>
        </member>
    </members>
</doc>
