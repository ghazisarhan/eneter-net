<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Eneter.Messaging.Framework.Phone</name>
    </assembly>
    <members>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IOutputConnector">
            <summary>
            Declares the output connector which provides a basic low-level functionality to open connection and send messages.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender">
            <summary>
            Declares the low-level sender of request messages and response messages.
            </summary>
            <remarks>
            IOutputConnector is derived from ISender so that it can send messages.
            IInputConnector uses ISender to send back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.SendMessage(System.Object)">
            <summary>
            Sends a message NOT using the stream. This method does not have to be implemented if IsStreamWritter returns false.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.SendMessage(System.Action{System.IO.Stream})">
            <summary>
            Sends a message using the stream. This method does not have to be implemented if IsStreamWritter returns true.
            </summary>
            <param name="toStreamWritter"></param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.ISender.IsStreamWritter">
            <summary>
            If it returns true then SendMessage(Action&lt;Stream&gt; toStreamWritter) will be used to send messages.
            </summary>
            <remarks>
            The point is that sometimes are messages sent using a stream and sometimes not. If this property
            returns true then the implementation of the sender expects messages are sent using the stream.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher">
            <summary>
            Declares the duplex dispatcher.
            </summary>
            <remarks>
            The duplex dispatcher has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel it forwards the message to all duplex output channels.<br/>
            The duplex dispatcher allows the bidirectional communication. It means, receivers to whom the message was forwarded can
            sand back response messages. Therefore, the sender can get response messages from all receivers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels">
            <summary>
            The interface declares methods to attach/detach multiple IDuplexInputChannel.
            </summary>
            <remarks>
            Some comunication components need to attach several channels. E.g. <see cref="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher"/>. <br/>
            Component using multiple duplex input channels is used in request-response communication and is
            able to listen to requests on more channels (addresses) and send back (to the right sender) the response message.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel nad starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel.
            Detaching the input channel stops listening to the messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.DetachDuplexInputChannel(System.String)">
            <summary>
            Detaches the duplex input channel.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels.AttachedDuplexInputChannels">
            <summary>
            Returns attached input channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.AddDuplexOutputChannel(System.String)">
            <summary>
            Adds the duplex output channel id to the dispatcher. The dispatcher will then start to forward
            the incoming messages also to this channel.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveDuplexOutputChannel(System.String)">
            <summary>
            Removes the duplex output channel from the dispatcher.
            </summary>
            <param name="channelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.RemoveAllDuplexOutputChannels">
            <summary>
            Removes all duplex output channels from the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcher.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the dispatcher.
            </summary>
            <param name="responseReceiverId">responseRecieverId after dispatching</param>
            <returns>responseReceiverId of the client connected to the dispatcher. Returns null if it does not exist.</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBroker">
            <summary>
            The interface declares the broker.
            The broker receives messages and forwards them to subscribed clients.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel">
            <summary>
            The interface declares methods to attach/detach one IDuplexInputChannel.
            </summary>
            <remarks>
            The duplex input channel is used in the request-response communication by a listener
            to receive request messages and send back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachDuplexInputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel)">
            <summary>
            Attaches the duplex input channel and starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.DetachDuplexInputChannel">
            <summary>
            Detaches the duplex input channel and stops listening to messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.IsDuplexInputChannelAttached">
            <summary>
            Returns true if the duplex input channel is attached.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel.AttachedDuplexInputChannel">
            <summary>
            Retutns attached duplex input channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the event.
            </summary>
            <param name="eventId">identification of published event.</param>
            <param name="serializedMessage">
            message content. If the message is not a primitive type or string then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String)">
            <summary>
            Subscribes for the event.
            </summary>
            <remarks>
            If you can call this method multiple times to subscribe for multile events.
            </remarks>
            <param name="eventId">identification of event that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Subscribe(System.String[])">
            <summary>
            Subscribes for list of events.
            </summary>
            <remarks>
            If you can call this method multiple times to subscribe for multile events.
            </remarks>
            <param name="eventIds">list of events that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SubscribeRegExp(System.String)">
            <summary>
            Subscribes for event types matching with the given regular expression.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the event id
            and will forward it to all subscribers.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            
            <example>
            Few examples for subscribing via regular expression.
            <code>
            // Subscribing for message types starting with the string MyMsg.Speed
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed);
            
            // Subscribing for message types starting with MyMsg.Speed or App.Utilities
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed|^App\.Utilities");
            </code>
            </example>
            </remarks>
            <param name="regularExpression">
            Regular expression that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.SubscribeRegExp(System.String[])">
            <summary>
            Subscribes for message types matching with the given list of regular expressions.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribers.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            </remarks>
            <param name="regularExpressions">
            List of regular expressions that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String)">
            <summary>
            Unsubscribes from the specified event.
            </summary>
            <param name="eventId">type of event which shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes from specified events.
            </summary>
            <param name="eventIds">list of events that shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.UnsubscribeRegExp(System.String)">
            <summary>
            Removes the regular expression subscription.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression string
            exists for the calling client. If yes, it will be removed.
            </remarks>
            <param name="regularExpression">Regular expression that was previously used for the subscription
            and now shall be removed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.UnsubscribeRegExp(System.String[])">
            <summary>
            Removes regular expression subscriptions.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression strings
            exist for the calling client. If yes, they will be removed.
            </remarks>
            <param name="regularExpressions">Regular expressions that shall be removed from subscriptions.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBroker.Unsubscribe">
            <summary>
            Unsubscribes from all types of events and regular expressions.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBroker.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed event is received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel">
            <summary>
            Declares the duplex output channel that can send messages to the duplex input channel and receive response messages.
            </summary>
            <remarks>
            Notice, the duplex output channel works only with duplex input channel and not with input channel.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.SendMessage(System.Object)">
            <summary>
            Sends the message to the address represented by ChannelId.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is not open.</exception>
            <exception cref="T:System.Exception">Any exception thrown during sending of a message. E.g. if sending via TCP fails.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.OpenConnection">
            <summary>
            Opens the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform using HTTP.
            If the message is sent via HTTP from the main Silverlight thread, then in case of a failure, the exception is not thrown.
            Therefore, it is recommended to execute this method in a different thread.
            </remarks>
            <exception cref="T:System.InvalidOperationException">If the connection is already open.</exception>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.CloseConnection">
            <summary>
            Closes the connection with the duplex input channel.
            </summary>
            <remarks>
            Notice, there is a limitation for the Silverlight platform.
            If this method is executed in the main Silverlight thread, then in case of a failure the exception will not be propagated.
            It is recommended to execute this method in a different thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionOpened">
            <summary>
            The event is invoked when the connection with the duplex input channel was opened.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed">
            <summary>
            The event is invoked when the connection with the duplex input channel was closed.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseMessageReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
            <remarks>
            Notice, this event is invoked in a different thread. The exception is only the Synchronous messaging that
            invokes this event in the thread calling the method SendResponseMessage in <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel"/>.
            Also, in Silverlight (and Windows Phone 7), http and tcp messagings have the possibility
            to choose if the thread shall be the main Silverlight thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ChannelId">
            <summary>
            Returns the id of the duplex input channel where messages are sent.
            It represents the address where messages are sent.
            </summary>
            <remarks>
            The channel id represents the communication address. The syntax of the channel id depends on the chosen
            communication. If the messaging is based on http, the address would be e.g.: http://127.0.0.1/Something/ or
            http://127.0.0.1:7345/Something/. If the communication is based on tcp, the address would be e.g.: tcp://127.0.0.1:7435/.
            For the named pipe, e.g. net.pipe://127.0.0.1/SomePipeName/.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ResponseReceiverId">
            <summary>
            Returns response receiving id of the duplex output channel.
            </summary>
            <remarks>
            The response receiver id is a unique identifier used by the duplex input channel to recognize
            connected duplex output channels.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected">
            <summary>
            Returns true if the duplex output channel is connected to the duplex input channel and listens to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ConnectionOpened, ConnectionClosed and ResponseMessageReceived events
            in desired thread. It allows to specify which threading mechanism/model is used to raise asynchronous events.
            E.g. events are queued and raised by one thread. Or e.g. in Silverlight events can be raised in the Silverlight thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory">
            <summary>
            Implements the factory to create duplex string message sender and receiver.
            </summary>
            <remarks>
            <example>
            Client sending and receiving text messages.
            <code>
            // Create string message sender.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach duplex output channel and be able to send messages and receive responses.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:9876/");
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            // Send a message.
            aSender.SendMessage("Hello.");
            
            ...
            
            // Do not forget to detach the output channel e.g. before application stops.
            // It will release the thread listening to response messages.
            aSender.DetachDuplexOutputChannnel();
            
            </code>
            </example>
            <example>
            Service sending and receiving text messages.
            <code>
            // Create string message receiver.
            IDuplexStringMessagesFactory aReceiverFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageReceiver aReceiver = aReceiverFactory.CreateDuplexStringMessageReciever();
            
            // Subscribe to receive responses.
            aReceiver.RequestReceived += OnRequestReceived;
            
            // Attach duplex input channel and start listening.
            IMessagingSystemFactory aMessaging = new TcpMessagingSystemFactory();
            IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("tcp://127.0.0.1:9876/");
            aReceiver.AttachDuplexInputChannel(anInputChannel);
            
            ...
            
            // Stop listening.
            aReceiver.DetachDuplexInputChannel();
            
            ...
            
            void OnRequestReceived(object sender, StringRequestReceivedEventArgs e)
            {
                IDuplexStringMessageReceiver aReceiver = (IDuplexStringMessageReceiver) sender;
                
                // Send back the response message.
                aReceiver.SendResponseMessage(e.ResponseReceiverId, "Hi, I am here.");
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory">
            <summary>
            The interface declares the factory to create duplex string message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageSender">
            <summary>
            Creates the duplex string message sender.
            </summary>
            <returns>duplex string message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory.CreateDuplexStringMessageReceiver">
            <summary>
            Creates the duplex string message receiver.
            </summary>
            <returns>duplex string message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from an xml string.
            The serializer is based on DataContractSerializer provided by .Net and it supports
            attributes (DataContract, DataMember, ...) specifying how data is serialized/deserialized.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.ISerializer">
            <summary>
            The interface declares the API for serialization and deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Serialize``1(``0)">
            <summary>
            Serializes data to object.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>
            Object representing the serialized data.
            Typically it can be byte[] or string.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.ISerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on DataContractSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.#ctor(System.Func{System.Type,System.Runtime.Serialization.XmlObjectSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method to instantiate DataContractSerializer
            with desired settings.
            </summary>
            <param name="dataContractFactoryMethod">
            The factory method responsible for creation of DataContractSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.DataContractXmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data serialized in xml string.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.SyncDispatching">
            <summary>
            Provides dispatcher that queues incoming methods and calls them synchronously one by one.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider">
            <summary>
            Provides dispatcher that invokes methods according to its threading model.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcherProvider.GetDispatcher">
            <summary>
            Returns dispatcher that can invoke methods according to its threading model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor">
            <summary>
            Constructs dispatching where each GetDispatcher() returns a new instance of the dispatcher.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.#ctor(System.Boolean)">
            <summary>
            Constructor which allows to specify if GetDispatcher() returns always the same dispatcher or GetDispatcher()
            returns always the new instance the dispatcher.
            </summary>
            <param name="isDispatcherShared">
            true - GetDispatcher() will return always the same instance of the dispatcher. It means all dispatchers returned from
            GetDispatcher() will sync incoming methods using the same queue. <br/>
            false - GetDispatcher() will return always the new instance of the dispatcher. It means each dispatcher returned from
            GetDispatcher() will use its own synchronization queue.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher that sync all incoming methods into one thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.MessageBus.NamespaceDoc">
            <summary>
            Publishing services via the message bus.
            </summary>
            <remarks>
            
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper">
            <summary>
            Implements the wrapper/unwrapper of data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Wrap(System.Object,System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Adds the data to already serialized data.
            </summary>
            <remarks>
            It creates the <see cref="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData"/> from the given data and serializes it with the provided serializer.<br/>
            </remarks>
            <param name="addedData">Added data. It must a basic .Net type. Otherwise the serialization will fail.</param>
            <param name="originalData">Already serialized data - it is type of string or byte[].</param>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DataWrapper.Unwrap(System.Object,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Takes the serialized WrappedData and deserializes it with the given serializer.
            </summary>
            <param name="wrappedData">data serialized by 'Wrap' method</param>
            <param name="serializer">serializer</param>
            <returns>deserialized WrappedData</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages with using .Net thread pool.
            </summary>
            <remarks>
            The messages are put to the queue of .Net thread pool. The receiving input channel is then called
            in the context of the assigned thread from the pool. Therefore the input channel can process more messages at once
            and also can notify the subscriber from more different threads at the same time. <br/>
            <b>Therefore do not forget to be careful and avoid race conditioning.</b>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory">
            <summary>
            Declares the factory that creates communication channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">unique identifier of the response receiver represented by this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">identifies the address, the duplex input channel listens to</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the thread pool.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.ThreadPoolMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector">
            <summary>
            Declares the input connector which provides a basic low-level listening.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StartListening(System.Func{Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageContext,System.Boolean})">
            <summary>
            Starts listening to messages.
            </summary>
            <param name="messageHandler">handler processing incoming messages. If it returns true the connection stays
            open and listener can loop for a next messages. If it returns false the listener shall not loop for the
            next message.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.CreateResponseSender(System.String)">
            <summary>
            In case the response receiver address comes inside the message
            the duplex input channel calls this method to get the response receiver.
            </summary>
            <param name="responseReceiverAddress"></param>
            <returns></returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IInputConnector.IsListening">
            <summary>
            Returns true if the listening is running.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.NamespaceDoc">
            <summary>
            Provides the messaging system which buffers sent messages if the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to temporarily store sent messages while the network connection is not available.
            Typical scenarios are:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be interrupted. In case of the disconnection, the sent messages are stored
            in the buffer while the connection tries to be automatically reopen. If the reopen is successful and the connection
            is established, the messages are sent from the buffer.
            <br/><br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. In case the application receiving
            messages is not up, the sent messages are stored in the buffer. Then when the receiving application is running, the messages
            are automatically sent from the buffer.
            
            <example>
            Simple client buffering messages in case of a disconnection.
            <code>
            // Create TCP messaging.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create buffered messaging that internally uses TCP.
            IMessagingSystemFactory aMessaging = new BufferedMessagingSystemFactory(anUnderlyingMessaging);
            
            // Create the duplex output channel.
            IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:8045/");
            
            // Create message sender to send simple string messages.
            IDuplexStringMessagesFactory aSenderFactory = new DuplexStringMessagesFactory();
            IDuplexStringMessageSender aSender = aSenderFactory.CreateDuplexStringMessageSender();
            
            // Subscribe to receive responses.
            aSender.ResponseReceived += OnResponseReceived;
            
            // Attach output channel an be able to send messages and receive responses.
            aSender.AttachDuplexOutputChannel(anOutputChannel);
            
            ...
            
            // Send a message. If the connection was broken the message will be stored in the buffer.
            // Note: The buffered messaging will try to reconnect automatically.
            aSender.SendMessage("Hello.");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcService`1">
            <summary>
            Declares service receiving requests via remote procedure calls.
            </summary>
            <typeparam name="TServiceInterface">
            Service interface.
            The provided type must be a non-generic interface which can declare methods and events.
            </typeparam>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverConnected">
            <summary>
            The event is invoked when the connection is opened.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcService`1.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the connection is closed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1">
            <summary>
            Declares client using remote procedure calls.
            </summary>
            <typeparam name="TServiceInterface">Service interface.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel">
            <summary>
            The interface declares methods to attach/detach one IDuplexOutputChannel.
            </summary>
            <remarks>
            The duplex output channel is used in the request-response communication by a sender
            to send request messages and receive response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachDuplexOutputChannel(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Attaches the duplex output channel and opens the connection for listening to response messages.
            </summary>
            <param name="duplexOutputChannel">Duplex output channel to be attached.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.DetachDuplexOutputChannel">
            <summary>
            Detaches the duplex output channel and stops listening to response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.IsDuplexOutputChannelAttached">
            <summary>
            Returns true if the reference to the duplex output channel is stored. <br/>
            </summary>
            <remarks>
            Notice, unlike version 1.0, the value 'true' does not mean the connection is open. If the duplex output
            channel was successfuly attached but the connection was broken, the channel stays attached but the connection is not open.
            To detect if the attached channel is listening to response messages, check the property <see cref="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.IsConnected"/>.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel.AttachedDuplexOutputChannel">
            <summary>
            Returns attached duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.SubscribeRemoteEvent``1(System.String,System.EventHandler{``0})">
            <summary>
            Subscribes to an event from the service.
            </summary>
            <typeparam name="TEventArgs">Type of the event args. It must be derived from EventArgs.</typeparam>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler processing the event</param>
            <remarks>
            Use this method if subscribing via the proxy is not suitable. (E.g. the proxy is not supported in Silverlight)
            If the method does not exist in the service interface the exception is thrown.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.UnsubscribeRemoteEvent(System.String,System.Delegate)">
            <summary>
            Unsubscribes from the event in the service.
            </summary>
            <param name="eventName">name of the event</param>
            <param name="eventHandler">event handler that shall be unsubscribed</param>
            <remarks>
            Use this method if subscribing via the proxy is not suitable. (E.g. the proxy is not supported in Silverlight)
            If the method does not exist in the service interface the exception is thrown.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.CallRemoteMethod(System.String,System.Object[])">
            <summary>
            Calls the method in the service.
            </summary>
            <param name="methodName">name of the method</param>
            <param name="args">list of arguments</param>
            <returns>returned value. null if it returns 'void'</returns>
            <remarks>
            Use this method if subscribing via the proxy is not suitable. (E.g. the proxy is not supported in Silverlight)
            If the method does not exist in the service interface the exception is thrown.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionOpened">
            <summary>
            Event raised when the connection with the service was open.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.Rpc.IRpcClient`1.ConnectionClosed">
            <summary>
            Event raised when the connection with the service was closed.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.NamespaceDoc">
            <summary>
            Functionality for writing and reading messages from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.StreamUtil">
            <summary>
            Internal helper functionality for reading data from a stream.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer">
            <summary>
            Implements the serialization/deserialization to/from XmlString.
            </summary>
            <remarks>
            The serializer internally uses XmlSerializer provided by .Net.
            <example>
            Serialization and deserialization example.
            <code>
            // Some class to be serialized.
            public class MyClass
            {
                public int Value1 { get; set; }
                public string Value2 { get; set; }
            }
            
            ...
            
            MyClass c = new MyClass;
            c.Value1 = 10;
            c.Value2 = "Hello World.";
            
            ...
            
            // Serialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aSerializedObject = aSerializer.Serialize&lt;MyClass&gt;(c);
            
            ...
            
            // Deserialization
            XmlStringSerializer aSerializer = new XmlStringSerializer();
            object aDeserializedObject = aSerializer.Deserialize&lt;MyClass&gt;(aSerializedObject);
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor">
            <summary>
            Creates the serializer based on XmlSerializer with default settings.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.#ctor(System.Func{System.Type,System.Xml.Serialization.XmlSerializer})">
            <summary>
            Creates the serializer that allows user to specify his own method instantiating XmlSerializer
            with desired settings.
            </summary>
            <param name="xmlSerializerFactoryMethod">
            The factory method responsible for creation of XmlSerializer.
            The factory method is called during the serialization or deserialization.<br/>
            The factory method can be called from more threads at the same time, so be sure, your factory method
            is thread safe.
            </param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the xml string.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>xml string</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <remarks>
            It internally XmlSerializer provided by .Net.
            </remarks>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher">
            <summary>
            Declares dispatcher that is responsible for invoking methods according to desired threading model.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.IThreadDispatcher.Invoke(System.Action)">
            <summary>
            Invokes the given delegate in the desired thread.
            </summary>
            <param name="workItem">delegate to be invoked</param>
        </member>
        <member name="T:System.Collections.Generic.HashSet`1">
            <summary>
            Represents a set of values.
            </summary>
            <remarks>
            (This is a stripped down Silverlight port of the full .NET CLR's <see cref="T:System.Collections.Generic.HashSet`1" /> class.
            The API is feature complete and compatible
            except for serialization implementations which are not supported by Silverlight.
            Some private methods called in operations with other <see cref="T:System.Collections.Generic.IEnumerable`1" />s
            are not implemented by taking advantage of some unsafe bit-level optimization code
            in certain constellations, but otherwise should work the same.
            This implementation is copied using the Reflector and thus the copyright is fully at Microsoft.
            It will remain here until the HashSet is included in a future version of the Silverlight base class library.)
            </remarks>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type,
            contains elements copied from the specified collection,
            and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Adds the specified element to a set.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>true if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; false if the element is already present.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.
            </summary>
            <param name="item">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <param name="count">The number of elements to copy to array.</param>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0 -or- count is less than 0.</exception>
            <exception cref="T:System.ArgumentException">arrayIndex is greater than the length of the destination array -or- count is greater than the available space from the index to the end of the destination array.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="other">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <returns>A Enumerator object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of other; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object overlaps the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and other share at least one common element; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.
            </summary>
            <param name="item">The element to remove.</param>
            <returns>true if the element is successfully found and removed; otherwise, false. This method returns false if item is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</returns>
            <exception cref="T:System.ArgumentNullException">match is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in both itself and in the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
            <exception cref="T:System.ArgumentNullException">other is null.</exception>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Gets the number of elements that are contained in a set.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase">
            <summary>
            The abstract class implementing the interface for attaching multiple input channels.
            The class also contains functionality to send (forward) messages via duplex output channels - the duplex input channel
            from the message is forwarded is remembered.
            The duplex output channels used for forwarding are not attached but dynamically created as they are needed.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.CloseConnections(System.Collections.Generic.IEnumerable{Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection})">
            <summary>
            Closes given connections with client duplex output channel.
            </summary>
            <param name="connections"></param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TConnection">
            <summary>
            Represents the connection between the duplex input channel and the duplex output channel.
            So when the response from the duplex output channel is received it can be forwarded to attached the
            duplex input channel with the correct response receiver id.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.AttachableMultipleDuplexInputChannelsBase.TDuplexInputChannelContext">
            <summary>
            The context of the duplex input channel consists of the attached duplex input channel and
            it also can contain the list of duplex output channels used to forward the message.
            E.g. The DuplexDispatcher receives the message from the attached duplex input channel and then forwards
            it to all duplex output channels.
            E.g. The DuplexChannelWrapper receives the message from the attached duplex input channel then wrapps
            the message and sends it via the duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouter">
            <summary>
            Declares the duplex router.
            </summary>
            <remarks>
            The duplex router has attached more duplex input channels and uses more duplex output channels.<br/>
            When it receives some message via the duplex input channel, it forwards the message to all configured duplex output channels.<br/>
            This router is bidirectional. Therefore, it can forward messages and also route back response messages from receivers.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.AddConnection(System.String,System.String)">
            <summary>
            Adds the connection configuration to the router. It means when the duplex input channel receives a
            message then the message will be forwarded to the specified duplex output channel too.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveConnection(System.String,System.String)">
            <summary>
            Removes the connection configuration from the router.
            </summary>
            <param name="duplexInputChannelId"></param>
            <param name="duplexOutputChannelId"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouter.RemoveAllConnections">
            <summary>
            Removes all configurations from the router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.NamespaceDoc">
            <summary>
            Publish-subscribe scenarios. Publishing and subscribing for notification messages.
            </summary>
            <remarks>
            The broker is intended for publish-subscribe scenarios. Clients can use the broker to publish notification messages or
            to subscribe for notification messages.<br/>
            The broker works like this:<br/>
            The client has some event that wants to notify to everybody who is interested. It sends the message to the broker.
            The broker receives the message and forwards it to everybody who is subscribed for such event.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.NamespaceDoc">
            <summary>
            Functionality for encoding/decoding the low-level communication between communicating channels.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs">
            <summary>
            The event arguments used for the notification whether the message was delivered or not delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event arguments.
            </summary>
            <param name="messageId">id of the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessageIdEventArgs.MessageId">
            <summary>
            Returns id of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver">
            <summary>
            The interface declares the reliable string message receiver.
            The reliable string message receiver can receiver string messages and response string messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.SendResponseMessage(System.String,System.String)">
            <summary>
            Sends the response message back to the duplex string message sender.
            </summary>
            <param name="responseReceiverId">identifies the duplex string message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.RequestReceived">
            <summary>
            The event is invoked when the message was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex string message sender opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageReceiver.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex string message sender closed the connection.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient">
            <summary>
            Declares the broker client.
            </summary>
            <remarks>
            The broker client allows to send messages via the broker, so that broker will forward them to all subscribers.<br/>
            It also allows to subscribe for messages the client is interested to.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SendMessage(System.String,System.Object)">
            <summary>
            Publishes the event via the broker.
            </summary>
            <param name="eventId">identifies the event</param>
            <param name="serializedMessage">
            message content. If the message is not a primitive type or string then the input parameter expects the message is already serialized!
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String)">
            <summary>
            Subscribes the client for the event.
            </summary>
            <param name="eventId">type of event that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Subscribe(System.String[])">
            <summary>
            Subscribes the client for list of events.
            </summary>
            <param name="eventIds">list of events that shall be observed</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String)">
            <summary>
            Subscribes the client for event types matching with the given regular expression.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the event id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            
            <example>
            Few examples for subscribing via regular expression.
            <code>
            // Subscribing for message types starting with the string MyMsg.Speed
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed);
            
            // Subscribing for message types starting with MyMsg.Speed or App.Utilities
            myDuplexBrokerClient.SubscribeRegExp(@"^MyMsg\.Speed|^App\.Utilities");
            </code>
            </example>
            </remarks>
            <param name="regularExpression">
            Regular expression that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.SubscribeRegExp(System.String[])">
            <summary>
            Subscribes the client for message types matching with the given list of regular expressions.
            </summary>
            <remarks>
            When a published message comes to the broker, the broker will check the message type id
            and will forward it to all subscribed clients.<br/>
            The broker will use the given regular expression to recognize whether the client is subscribed
            or not.<br/>
            The .NET based Broker internally uses Regex class to evaluate the regular expression.<br/>
            The Java based Broker internally uses Pattern class to evaluate the regular expression.<br/>
            Regular expressions between .NET and Java does not have to be fully compatible.
            </remarks>
            <param name="regularExpressions">
            List of regular expressions that will be evaluated by the broker to recognize whether the client is subscribed.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String)">
            <summary>
            Unsubscribes the client from the specified event.
            </summary>
            <param name="eventId">type of event which shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe(System.String[])">
            <summary>
            Unsubscribes the client from specified events.
            </summary>
            <param name="eventIds">list of events that shall not be observed anymore</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String)">
            <summary>
            Removes the regular expression subscription.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression string
            exists for the calling client. If yes, it will be removed.
            </remarks>
            <param name="regularExpression">Regular expression that was previously used for the subscription
            and now shall be removed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.UnsubscribeRegExp(System.String[])">
            <summary>
            Removes regular expression subscriptions.
            </summary>
            <remarks>
            When the broker receives this request, it will search if the given regular expression strings
            exist for the calling client. If yes, they will be removed.
            </remarks>
            <param name="regularExpressions">Regular expressions that shall be removed from subscriptions.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.Unsubscribe">
            <summary>
            Unsubscribes this client from all types of events and regular expressions.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.Broker.IDuplexBrokerClient.BrokerMessageReceived">
            <summary>
            The event is invoked when the observed event is received from the broker.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages between threads by using the working
            thread processing messages from the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory">
            <summary>
            The factory class implements the messaging system delivering messages synchronously in the caller thread.
            It creates output and input channels using the caller thread to deliver messages.
            <br/><br/>
            Different instances of SynchronousMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message through this messaging system
            then output and input channels must be created with the same instance of SynchronousMessagingSystemFactory.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory representing the messaging system.
            Note: Every instance of the synchronous messaging system factory represents one messaging system.
                  It means that two instances of this factory class creates channels for two independent messaging system.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs the factory representing the messaging system.
            </summary>
            <param name="protocolFormatter">formatter used to encode low-level messages between channels</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel communicating with the specified duplex input channel using synchronous local call.
            The duplex output channel can send messages and receive response messages.
            </summary>
            <param name="channelId">identifies the receiving duplex input channel</param>
            <param name="responseReceiverId">identifies the response receiver of this duplex output channel</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel listening to messages on the specified channel id.
            The duplex input channel can send response messages back to the duplex output channel.
            </summary>
            <param name="channelId">identifies this duplex input channel</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.SynchronousMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages via HTTP.
            </summary>
            <remarks>
            It creates the communication channels using HTTP for sending and receiving messages.
            The channel id must be a valid URI address. E.g.: http://127.0.0.1/something/ or https://127.0.0.1/something/. <br/>
            Because HTTP is request-response based protocol, it does not keep the connection open.
            Therefore, for the bidirectional communication used by duplex channels, the polling mechanism is used.
            The duplex output channel regularly polls for response messages and the duplex input channel constantly measures the inactivity time
            to recognize whether the duplex output channel is still connected.<br/><br/>
            Notice, to start listening via input channel (or duplex input channel), the application must be executed with sufficient rights.
            Otherwise the exception will be thrown.<br/>
            Also notice, Silverlight and Windows Phone 7 do not support listening to HTTP requests.
            Therefore, only sending of messages (and receiving response messages) is possible in these platforms.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor">
            <summary>
            Constructs the factory that will create channels with default settings. The polling
            frequency will be 500 ms and the inactivity timeout will be 10 minutes.
            </summary>
            <remarks>
            The polling frequency and the inactivity time are used only by duplex channels.
            The polling frequency specifies how often the duplex output channel checks if there are pending response messages.
            The inactivity time is measured by the duplex input channel and specifies the maximum time, the duplex output channel
            does not have to poll for messages.
            If the inactivity time is exceeded, considers the duplex output channel as disconnected.
            <br/><br/>
            In case of Silverlight or Windows Phone 7, the response messages are recieved in the main Silverlight thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            The response messages are received in the main silverlight thread.
            </summary>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="receiveInSilverlightThread">true if the response messages shall be received in the main silverlight thread</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.#ctor(System.Int32,System.Boolean,Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter{System.Byte[]})">
            <summary>
            Constructs the factory that will create channel with specified settings.
            </summary>
            <remarks>
            </remarks>
            <param name="pollingFrequency">how often the duplex output channel polls for the pending response messages</param>
            <param name="receiveInSilverlightThread">true if the response messages shall be received in the main silverlight thread</param>
            <param name="protocolFormatter">formatter for low-level messages between duplex output channel and duplex input channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel. The channel id must be a valid address of the receiver. e.g. 127.0.0.1:8090</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using HTTP.
            The channel id must be a valid URI address e.g. http://127.0.0.1:8090/something/
            The method is not supported in Silverlight and Windows Phone 7.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">channel id specifying the address the duplex input channel listens to.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.myPollingFrequency">
            <summary>
            Defines how often the client poll the server for response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType">
            <summary>
            Indicates the type of the low-level protocol message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.Unknown">
            <summary>
            Unknown message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.OpenConnectionRequest">
            <summary>
            Open connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.CloseConnectionRequest">
            <summary>
            Close connection request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.PollRequest">
            <summary>
            Poll request message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType.MessageReceived">
            <summary>
            Message or reaponse message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage">
            <summary>
            Represents decoded low-level protocol message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.EProtocolMessageType,System.String,System.Object)">
            <summary>
            Constructs the protocol message from the given parameters.
            </summary>
            <param name="messageType">type of the message</param>
            <param name="responseReceiverId">client id</param>
            <param name="message">message content</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.ResponseReceiverId">
            <summary>
            Client id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolMessage.Message">
            <summary>
            The content of the message or response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory">
            <summary>
            Provides the messaging system which monitors the connection in the underlying messaging system.
            </summary>
            <remarks>
            When the connection is monitored, the duplex output channel periodically sends 'ping' messages
            to the duplex input channel and waits for responses.
            If the response comes within the specified timeout, the connection is open.
            <br/>
            On the receiver side, the duplex input channel waits for the 'ping' messages and monitors if the connected
            duplex output channel is still alive. If the 'ping' message does not come within the specified timeout,
            the particular duplex output channel is disconnected.
            <br/><br/>
            Notice, the output channel and the input channel do not maintain an open connection.
            Therefore, the monitored messaging is not applicable for them. The implementation of this factory just uses
            the underlying messaging to create them.
            <br/><br/>
            <b>Note</b>
            Channels created by monitored messaging factory cannot communicate with channels, that were not created
            by monitored factory. E.g. the channel created with the monitored messaging factory with underlying TCP
            will not communicate with channels created directly with TCP messaging factory. The reason is, the
            communicating channels must understand the 'ping' communication.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 3s (1s + 2s). Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory from specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
            <param name="serializer">serializer used to serialize 'ping' messages</param>
            <param name="pingFrequency">how often the duplex output channel pings the connection</param>
            <param name="pingResponseTimeout">
            For the duplex output channel: the maximum time, the response for the ping must be received
            <br/>
            For the duplex input channel: pingFrequency + pingResponseTimeout = the maximum time within the ping for the connected duplex output channel
            must be received.
            </param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="!:ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            The channel also regularly checks if the connection is available. It sends 'ping' messages and expect 'ping' responses
            within the specified timeout. If the 'ping' response does not come within the specified timeout, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of the channel</param>
            <returns>composit duplex output channel <see cref="!:ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            It also checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            timeout, the duplex output channel is disconnected. The event <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/>
            is invoked.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel <see cref="!:ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory">
            <summary>
            Extends the messaging system to work temporarily offline while the connection is not available.
            </summary>
            <remarks>
            The buffered messaging is intended to overcome relatively short time intervals when the connection is not available.
            It means, the buffered messaging is able to hide the connection is not available and work offline while
            trying to reconnect.<br/>
            If the connection is not available, the buffered messaging stores sent messages (and sent response messages)
            in the buffer and sends them when the connection is established.<br/>
             
            Typical scenarios for buffered messaging:
            <br/><br/>
            <b>Short disconnections</b><br/>
            The network connection is unstable and can be anytime interrupted. In case of the disconnection, sent messages are stored
            in the buffer while the connection tries to be reopen. If the connection is established again,
            the messages are sent from the buffer.<br/>
            <br/>
            <b>Independent startup order</b><br/>
            The communicating applications starts in undefined order and initiates the communication. 
            The buffered messaging stores messages in the buffer while receiving application is started and ready to receive
            messages.<br/> 
            <br/>
            <b>Note:</b><br/>
            The buffered messaging does not require, that both communicating parts create channels with buffered messaging factory.
            It means, e.g. the duplex output channel created with buffered messaging with underlying TCP, can send messages
            directly to the duplex input channel created with just TCP messaging factory.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default parameters.
            </summary>
            <remarks>
            The maximum offline time will be set to 10 seconds.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,System.TimeSpan)">
            <summary>
            Constructs the factory from the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system e.g. Websocket, TCP, ...</param>
            <param name="maxOfflineTime">the max time, the communicating applications can be disconnected</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the messages are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="!:ICompositeDuplexOutputChannel"/> </returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            If the connection is not established, it puts sent messages to the buffer while trying to reconnect.
            Then when the connection is established, the message are sent from the buffer.
            If the reconnect is not successful within the maximum offline time, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/> and messages
            are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">response receiver id of this duplex output channel</param>
            <returns>composit duplex output channel with the buffer <see cref="!:ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            If the connection with the duplex output channel is not established, it puts sent response messages to the buffer.
            Then, when the duplex input channel is connected, the response messages are sent.
            If the duplex output channel does not connect within the specified maximum offline time, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and response messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="!:ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.VoidMessage">
            <summary>
            Represents an empty data type 'void'.
            Can be used if no type is expected as a message.
            </summary>
            <remarks>
            <example>
            The following example shows how to use VoidMessage to declare a message sender
            sending string messages and receiving "nothing".
            <code>
            ...
            IDuplexTypedMessageSender&lt;VoidMessage, string&gt; myMessageSender;
            ...
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Serialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Serializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of serialized data</param>
            <param name="dataToSerialzier">data to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.SerializerExt.Deserialize(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Type,System.Object)">
            <summary>
            Deserializes using Type instead of generics.
            </summary>
            <param name="serializer">serializer derived from ISerializer</param>
            <param name="dataType">type of deserialized data</param>
            <param name="serializedData">data to be deserialized</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.NamespaceDoc">
            <summary>
            The namespace contains the supporting functionality for queueing and processing messages with multiple threads.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.DuplexRouterFactory">
            <summary>
            Implements the factory creating duplex router.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory">
            <summary>
            Declares the factory creating duplex router.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.IDuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex router factory.
            </summary>
            <param name="duplexOutputChannelMessaging">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Router.DuplexRouterFactory.CreateDuplexRouter">
            <summary>
            Creates the duplex router.
            </summary>
            <returns>duplex router</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelWrapper">
            <summary>
            Declares the duplex channel wrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel wrapper' can communication only with 'duplex channel unwrapper'.
            It cannot communicate with one-way 'channel unwrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a message from the attached duplex input channel is received.
            The received message is wrapped and sent to the duplex output channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelWrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            The method is called when a reponse message is received from the duplex output channel.
            The received response is unwrapped and sent as a response to the matching duplex input channel.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.NamespaceDoc">
            <summary>
            Interfaces representing the messaging system.
            </summary>
            <remarks>
            The messaging system is responsible for delivering messages from a sender to a receiver through communication channels.
            <br/><br/>
            For the one-way communication, the messaging system provides the output channel and the input channel.
            The output channel sends messages to the input channel with the same channel id.
            <br/><br/>
            For the bidirectional communication, the messaging system provides the duplex output channel and the duplex input channel.
            The duplex output channel sends messages to the duplex input channel with the same channel id and can receive response messages.
            The duplex input channel receives messages and can send back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.HttpRequestInvoker.InvokeNotInSilverlightThread(System.Action)">
            <summary>
            This method is workaround for the Silverlight bug.
            The problem is, that when the asynchronous HttpRequest is invoked, it is not possible to wait
            in the Silverlight thread until it is completed. --> It hangs.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.NamespaceDoc">
            <summary>
            Monitoring the connection between communicating applications.
            </summary>
            <remarks>
            The monitoring is realized by sending 'ping' messages and receiving 'ping' responses.
            If the sending of the 'ping' fails or the 'ping' response is not received within the specified
            time, the connection is considered to be broken.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel">
            <summary>
            Declares the duplex input channel that can receive messages from the duplex output channel and send back response messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StartListening">
            <summary>
            Starts listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.StopListening">
            <summary>
            Stops listening to messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.SendResponseMessage(System.String,System.Object)">
            <summary>
            Sends the response message back to the connected IDuplexOutputChannel.
            </summary>
            <param name="responseReceiverId">Identifies the response receiver. The identifier comes with received messages.</param>
            <param name="message">response message</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.DisconnectResponseReceiver(System.String)">
            <summary>
            Disconnects the response receiver.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex output channel opened the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex output channel closed the connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.MessageReceived">
            <summary>
            The event is invoked when a message was received.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ChannelId">
            <summary>
            Returns id of this duplex input channel.
            The id represents the 'address' the duplex input channel is listening to.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.IsListening">
            <summary>
            Returns true if the duplex input channel is listening.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.Dispatcher">
            <summary>
            Returns dispatcher that defines the threading model for raising events.
            </summary>
            <remarks>
            Dispatcher is responsible for raising ResponseReceiverConnected, ResponseReceiverDisconnected and MessageReceived events
            in desired thread. It allows to specify which threading mechanism/model is used to raise asynchronous events.
            E.g. events are queued and raised by one thread. Or e.g. in Silverlight events can be raised in the Silverlight thread.<br/>
            The only exception is the event ResponseReceiverConnecting which is not dispatched to any specific thread because
            it may set a value which needs to be checked when it returns.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs">
            <summary>
            The event is invoked when a string response message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.#ctor(System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringResponseReceivedEventArgs.ResponseMessage">
            <summary>
            Returns the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace">
            <summary>
            Implements the functionality for tracing messages.
            </summary>
            <remarks>
            The EneterTrace allows to trace error messages, warning message, info messages and debug messages.
            It also allows to trace entering and leaving from a method and measures the time spent in the method.
            In order to trace entering - leaving and debug messages, you must set the detail level to 'Debug'.<br/>
            <br/>
            Notice: The trace does not display namespaces and method names in Compact Framework platform.
            <example>
            Tracing entering and leaving and a warning message.
            <code>
            private class MyClass
            {
                private void MyMethod()
                {
                    // Tracing entering and leaving the method.
                    // Note: The entering-leaving is traced only if detail level is 'Debug'.
                    using (EneterTrace.Entering())
                    {
                        ... method implementation ...
                        
                        // Tracing a warning message.
                        EneterTrace.Warning("This is a warning message.");
                        
                        ...
                    }
                }
            }
            
            The output:
            11:59:11.365 ~008 --> YourNameSpace.MyClass.MyMethod
            11:59:11.704 ~008  W: YourNameSpace.MyClass.MyMethod This is a warning message.
            11:59:12.371 ~008 &lt;--  YourNameSpace.MyClass.MyMethod [00:00:01 000ms 969.0us]
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Entering">
            <summary>
            Traces entering-leaving the method.
            </summary>
            <remarks>
            The enetering information for the method calling this constructor is put to the trace
            and the measuring of the time starts.
            In order to trace entering-leaving, the detail level must be set to 'Debug'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.System#IDisposable#Dispose">
            <summary>
            Traces the leaving from the method including the duration time.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.String)">
            <summary>
            Traces the information message.
            </summary>
            <param name="message">info message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Info(System.String,System.Exception)">
            <summary>
            Traces the info message.
            </summary>
            <param name="message">info message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String)">
            <summary>
            Traces warning message.
            </summary>
            <param name="message">warning message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.String)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="details">additional details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Warning(System.String,System.Exception)">
            <summary>
            Traces the warning message.
            </summary>
            <param name="message">warning message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.String)">
            <summary>
            Traces the error message and details for the error.
            </summary>
            <param name="message">error message</param>
            <param name="errorDetails">error details</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Error(System.String,System.Exception)">
            <summary>
            Traces the error message.
            </summary>
            <param name="message">error message</param>
            <param name="err">exception that will be traced</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.Debug(System.String)">
            <summary>
            Traces the debug message.
            </summary>
            <remarks>
            To trace debug messages, the detail level must be set to debug.
            </remarks>
            <param name="message">error message</param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StartProfiler">
            <summary>
            Starts the profiler measurement.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.StopProfiler">
            <summary>
            Stops the profiler measurement and writes results to the trace.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.EnqueueJob(System.Action)">
            <summary>
            Enqueues a job to the queue.
            </summary>
            <remarks>
            The queueing of jobs ensures, the jobs are performed in the correct order
            and the writing of the processing does not consume the execution thread.
            </remarks>
            <param name="job"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.ProcessJobs(System.Object)">
            <summary>
            Removes traces from the queue and writes them.
            </summary>
            <remarks>
            The method is executed from a different thread.
            The thread then loops until the queue is processed.
            </remarks>
            <param name="x"></param>
        </member>
        <member name="M:Eneter.Messaging.Diagnostic.EneterTrace.#ctor">
            <summary>
            Private helper constructor.
            </summary>
            <remarks>
            The constructor is private, so the class can be enstantiating only via the 'Entering' method.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.TraceLog">
            <summary>
            Sets or gets the user defined trace.
            </summary>
            <remarks>
            If the value is set, the trace messages are written to the specified trace and to the debug port.
            If the value is null, then messages are written only to the debug port.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.DetailLevel">
            <summary>
            Sets or gets the detail level of the trace.
            </summary>
            <remarks>
            If the detail level is set to 'Short' then only info, warning and error messages are traced.<br/>
            If the detail level is set to 'Debug' then all messages are traced.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.Diagnostic.EneterTrace.NameSpaceFilter">
            <summary>
            Sets or gets the regular expression that will be applied to the namespace to filter traced messages.
            </summary>
            <remarks>
            Sets or gets the regular expression that will be applied to the name space of the traced message.
            If the namespace matches with the regular expression, the message will be traced.
            If the filter is set to null, then the filter is not used and all messages will be traced.
            <example>
            The following example shows how to set the filter to trace a certain namespace.
            <code>
            // Set the debug detailed level.
            EneterTrace.DetailLevel = EneterTrace.EDetailLevel.Debug;
            
            // Examples:
            // Traces all name spaces starting with 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace");
            
            // Traces exactly the name space 'My.NameSpace'.
            EneterTrace.NameSpaceFilter = new Regex(@"^My\.NameSpace$");
            
            // Traces name spaces starting with 'Calc.Methods' or 'App.Utilities'.
            EneterTrace.NameSpaceFilter = new Regex(@"^Calc\.Methods|^App\.Utilities");
            
            // Traces all name spaces except namespaces starting with 'Eneter'.
            EneterTrace.NameSpaceFilter = new Regex(@"^(?!\bEneter\b)");
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel">
            <summary>
            Detail level of the trace.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.None">
            <summary>
            Messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Short">
            <summary>
            Info, Warning and Error messages.<br/>
            The debug messages and entering-leaving messages are not traced.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Diagnostic.EneterTrace.EDetailLevel.Debug">
            <summary>
            All messages are traced.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData">
            <summary>
            The data structure representing the wrapped data.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor">
            <summary>
            Default constructor used for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.#ctor(System.Object,System.Object)">
            <summary>
            Constructs wrapped data from input parameters.
            </summary>
            <param name="addedData">new data added to the original data</param>
            <param name="originalData">original data</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.AddedData">
            <summary>
            Newly added data.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.ChannelWrapper.WrappedData.OriginalData">
            <summary>
            Original (wrapped) data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.EBrokerRequest">
            <summary>
            Specifies the broker request.
            </summary>
            <remarks>
            The request for the broker is the message that is intended for the broker and not for the subscribers.
            This message is used by the broker client to subscribe and unsubscribe.
            </remarks>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Subscribe">
            <summary>
            Request to subscribe exactly for the specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.SubscribeRegExp">
            <summary>
            Request to subscribe for message type ids that match with the regular expression.
            I.e. regular expression is used to identify what message types shall be notified
            to the client.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Unsubscribe">
            <summary>
            Request to unsubscribe from exactly specified message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeRegExp">
            <summary>
            Request to unsubscribe the regular expression.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.UnsubscribeAll">
            <summary>
            Request to unsubscribe all messages and regular expressions.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.Nodes.Broker.EBrokerRequest.Publish">
            <summary>
            Request to publish a message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessage">
            <summary>
            Internal message used between DuplexBroker and DuplexBrokerClient.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor">
            <summary>
            Default constructor used by a deserializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(Eneter.Messaging.Nodes.Broker.EBrokerRequest,System.String[])">
            <summary>
            Constructs the message requesting the broker to subscribe or unsubscribe events.
            </summary>
            <param name="request">subscribing or unsubscribing</param>
            <param name="messageTypes">events to be subscribed or unsubscribed.</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the broker message requesting the broker to publish an event.
            </summary>
            <param name="messageTypeId">message type that shall be published</param>
            <param name="message">serialized message to be published</param>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Request">
            <summary>
            Type of the request.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.MessageTypes">
            <summary>
            Array of message types.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessage.Message">
            <summary>
            Serialized message that shall be notified to subscribers.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadPoolMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transfering messages between threads by using the thread pool.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultDuplexInputChannel.CreateResponseMessageSender(Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.MessageContext,System.String)">
            <summary>
            Creates the connection if does not exist.
            Returns false if the opening the connection was not approved - user rejected the connection via the connection token.
            </summary>
            <param name="messageContext"></param>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs">
            <summary>
            Event argument representing the response receiver on the service site.
            </summary>
            <remarks>
            This event argument is typically used e.g. when the client opened/closed connection. 
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.#ctor(System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
            <remarks>
            This id identifies who receives the response message on the client side.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels. 
            </summary>
            <typeparam name="T">type of encoded data. It can be byte[] or String.</typeparam>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter">
            <summary>
            Declares functionality to encode and decode messages used for the communication between channels.
            </summary>
            <remarks>
            Encoded messages are presented as type of object. This interface is used if it is not needed to know
            if the encoded messages are byte[] or string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the open connection request message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes the close connecion request message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">client id. It is empty string in case of output channel.</param>
            <param name="message">message serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes a message or a response message to the stream.
            </summary>
            <param name="responseReceiverId">id of the client that wants to send the message. It is empty string if the response message is sent.</param>
            <param name="message">serialized message to be sent.</param>
            <param name="outputSream">output where the encoded message is written</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter.DecodeMessage(System.Object)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes the open connection request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel to open the connection with the duplex input channel.
            </remarks>
            <param name="responseReceiverId">id of the client opening the connection.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes the close connecion request message.
            </summary>
            <remarks>
            The message is used by the duplex output channel or duplex input channel to close the connection.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to disconnect or that will be disconnected</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <remarks>
            The message is used by output channel or duplex output channel to send messages or
            by duplex input channel to send response messages.
            </remarks>
            <param name="responseReceiverId">id of the client that wants to send the message. It is empty string if the response message is sent.</param>
            <param name="message">serialized message to be sent.</param>
            <returns>encoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes message from the stream.
            </summary>
            <param name="readStream">stream to be read</param>
            <returns>decoded message</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter`1.DecodeMessage(`0)">
            <summary>
            Decodes message from the given object.
            </summary>
            <param name="readMessage">reference to the object.</param>
            <returns>decoded message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter">
            <summary>
            Implements the protocol formatter encoding the low-level messages into the string.
            </summary>
            <remarks>
            Encoding to the string can be used if the messaging system does not allow tu use byte[].
            E.g. the messaging between Silverlight applications sends only string messages.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1">
            <summary>
            Abstract internal class providing default implementation for formatting communication before channels.
            </summary>
            <remarks>
            The default implemention of all methods throws NotSupportedException.
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Returns encoded 'open connection' message.
            </summary>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'open connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Returns encoded 'close connection' message.
            </summary>
            <param name="responseReceiverId"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'close connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeMessage(System.String,System.Object)">
            <summary>
            Returns encoded 'request message' or 'response message'.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes 'request message' or 'response message' directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message from the stream.
            </summary>
            <param name="readStream"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.ProtocolFormatterBase`1.DecodeMessage(`0)">
            <summary>
            Decodes the message.
            </summary>
            <param name="readMessage"></param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterStringProtocolFormatter.DecodeMessage(System.String)">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="encodedMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.Attachable.NamespaceDoc">
            <summary>
            Interfaces used by components to be able to attach channels.
            </summary>
            <remarks>
            In order to be able to send messages, all communication components must be able to attach channels.
            E.g. if a component needs to send messages and receive responses then it must implement
            <see cref="T:Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel"/> to be able to attach <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel"/>.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue">
            <summary>
            Implements the queue for messages of type object.
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty, then the thread reading messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1">
            <summary>
            Implements the message queue.
            One or more threads can put messages into the queue and other threads
            can remove them.
            If the queue is empty, then the thread reading the messages is blocked until the message
            is put to the queue or the thread is unblocked.
            </summary>
            <typeparam name="_MessageType">Type of the message.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.EnqueueMessage(`0)">
            <summary>
            Puts message to the queue.
            </summary>
            <param name="message">message that shall be enqueued</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>message, it returns null if the waiting thread was unblocked but there is no message in the queue.</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <returns>
            message, it returns null if the waiting thread was unblocked but there is no message in the queue.
            </returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.DequeueMessage(System.Int32)">
            <summary>
            Removes the first message from the queue. If the queue is empty the thread is blocked until the specified timeout.
            The method UnblockProcesseingThreads() unblocks threads waiting in this method.
            </summary>
            <param name="millisecondsTimeout">Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.</param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.PeekMessage(System.Int32)">
            <summary>
            Reads the first message from the queue. If the queue is empty the thread is blocked until a message is put to the queue.
            To unblock waiting threads, use UnblockProcesseingThreads().
            </summary>
            <param name="millisecondsTimeout">
            Maximum waiting time for the message. If the time is exceeded the TimeoutException is thrown.
            </param>
            <returns>message</returns>
            <exception cref="T:System.TimeoutException">when the specified timeout is exceeded</exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Clear">
            <summary>
            Deletes all items from the message queue.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.UnblockProcessingThreads">
            <summary>
            Releases all threads waiting for messages in DequeueMessage() and sets the queue to the unblocking mode.
            </summary>
            <remarks>
            When the queue is in unblocking mode, the dequeue or peek will not block if data is not available but
            it will return null or default values.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.BlockProcessingThreads">
            <summary>
            Sets the queue to the blocking mode.
            </summary>
            <remarks>
            When the queue is in blocking mode, the dequeue and peek will block until data is available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.WaitForQueueCall(System.Func{`0})">
            <summary>
            Waits until something is in the queue and then calls the specified delegate.
            If the waiting thread is released (by UnblockProcessingThreads) but the queue is still empty, it returns the default
            value of the specified template type.
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myMessageQueue">
            <summary>
            Queue for messages.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.myIsBlockingMode">
            <summary>
            Indicates weather the reading from the queue blocks until data is available.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.IsBlockingMode">
            <summary>
            Returns true if the queue blocks threads during dequeue and peek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.MessageQueueing.MessageQueue`1.Count">
            <summary>
            Returns number of messages in the queue.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory">
            <summary>
            Implements the factory for creating channel wrapper and unwrapper.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory">
            <summary>
            Declares the factory for creating channel wrappers and and channel unwrappers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates the duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the duplex channel unwrapper.
            </summary>
            <param name="outputMessagingSystem">Messaging used to create output channels where unwrapped messages will be sent.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor">
            <summary>
            Constructs the channel wrapper factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the channel wrapper factory with specified serializer.
            </summary>
            <param name="serializer">serializer</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelWrapper">
            <summary>
            Creates duplex channel wrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.ChannelWrapperFactory.CreateDuplexChannelUnwrapper(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates duplex channel unwrapper.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory">
            <summary>
            The interface declares the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connenction provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider">
            <summary>
            The interface declares methods for convenient attaching of channels and
            for connecting senders and receivers with channels.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,System.String)">
            <summary>
            Creates and attaches the duplex input channel to the component that can have attached multiple duplex input channels.
            </summary>
            <param name="inputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Attach(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates and attaches the duplex output channel to the component.
            </summary>
            <param name="outputComponent">Component.</param>
            <param name="channelId">Channel Id of the channel that will be created.</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexInputChannel,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.Connect(Eneter.Messaging.Infrastructure.Attachable.IAttachableMultipleDuplexInputChannels,Eneter.Messaging.Infrastructure.Attachable.IAttachableDuplexOutputChannel,System.String)">
            <summary>
            Creates the duplex input channel and duplex output channel and then connects the receiver and sender.
            </summary>
            <param name="inputComponent">duplex input channel attachable component (receiver)</param>
            <param name="outputComponent">duplex output channel attachable component (sender)</param>
            <param name="channelId">channel id</param>
        </member>
        <member name="P:Eneter.Messaging.Infrastructure.ConnectionProvider.IConnectionProvider.MessagingSystem">
            <summary>
            Returns the messaging system used by the connection provider.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2">
            <summary>
            Message sender that sends a request message and then waits until the response is received.
            </summary>
            <typeparam name="TResponse">Response message type.</typeparam>
            <typeparam name="TRequest">Request message type.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the request message and returns the response.
            </summary>
            <param name="message">request message</param>
            <returns>response message</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.ISyncDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
            <remarks>
            Notice, the event is raised in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory">
            <summary>
            Implements the factory to create reliable typed message sender and receiver.
            </summary>
            <remarks>
            The reliable messaging means that the sender of a message is notified whether the message was delivered or not.
            <example>
            Service using the reliable communication. When it sends the response message it is notified whether the message
            was delivered or not.
            <code>
            using System;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorService
            {
                // Request message.
                public class RequestMessage
                {
                    public int Number1 { get; set; }
                    public int Number2 { get; set; }
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result { get; set; }
                }
            
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Create reliable message receiver.
                        IReliableTypedMessagesFactory aReceiverFactory = new ReliableTypedMessagesFactory();
                        IReliableTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; aReceiver =
                            aReceiverFactory.CreateReliableDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to be notified whether sent response messages
                        // were received.
                        aReceiver.ResponseMessageDelivered += OnResponseMessageDelivered;
                        aReceiver.ResponseMessageNotDelivered += OnResponseMessageNotDelivered;
            
                        // Subscribe to process request messages.
                        aReceiver.MessageReceived += OnMessageReceived;
            
                        // Use WebSocket for the communication.
                        // Note: You can also other messagings. E.g. TcpMessagingSystemFactory
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the input channel to the receiver and start listening.
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
            
                        Console.WriteLine("The calculator service is running. Press ENTER to stop.");
                        Console.ReadLine();
            
                        // Detach the input channel to stop listening.
                        aReceiver.DetachDuplexInputChannel();
                    }
            
                    private static void OnMessageReceived(object sender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
                    {
                        // Calculate numbers.
                        ResponseMessage aResponseMessage = new ResponseMessage();
                        aResponseMessage.Result = e.RequestMessage.Number1 + e.RequestMessage.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResponseMessage.Result);
            
                        // Send back the response message.
                        var aReceiver = (IReliableTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;)sender;
                        string aResponseId = aReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
            
                        Console.WriteLine("Sent response has Id: {0}", aResponseId);
                    }
            
                    private static void OnResponseMessageDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        Console.WriteLine("Response Id: {0} was delivered.", e.MessageId);
                    }
            
                    private static void OnResponseMessageNotDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        Console.WriteLine("Response Id: {0} was NOT delivered.", e.MessageId);
                    }
                }
            }
            </code>
            </example>
            
            <example>
            Client using the reliable communication. When it sends the request message it is notified whether
            it was delivered or not.
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClientSync
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private IReliableTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IReliableTypedMessagesFactory aSenderFactory = new ReliableTypedMessagesFactory();
                        mySender = aSenderFactory.CreateReliableDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to be notified whether the request message was delivered or not.
                        mySender.MessageDelivered += OnMessageDelivered;
                        mySender.MessageNotDelivered += OnMessageNotDelivered;
            
                        // Subscribe to receive response messages.
                        mySender.ResponseReceived += OnResponseReceived;
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        string aRequestId = mySender.SendRequestMessage(aRequest);
            
                        SentMessageIdlabel.Text = "Request Id: " + aRequestId;
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                    {
                        // Display the result using the UI thread.
                        UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                    }
            
                    private void OnMessageDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        // Display the message was delivered.
                        UI(() =&gt; DeliveryResultLabel.Text = "Delivered: " + e.MessageId);
                    }
            
                    private void OnMessageNotDelivered(object sender, ReliableMessageIdEventArgs e)
                    {
                        // Display the message was NOT delivered.
                        UI(() =&gt; DeliveryResultLabel.Text = "NOT delivered: " + e.MessageId);
                    }
            
                    // Helper method to invoke a delegate in the UI thread.
                    // Note: You can manipulate UI controls only from the UI tread.
                    private void UI(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action();
                        }
                    }
                }
            }
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory">
            <summary>
            The interface declares the factory to create reliable typed message sender and receiver.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response messages</typeparam>
            <typeparam name="_RequestType">type of request messages</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum time, the acknowledge message must be received is set to 12 seconds.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(System.TimeSpan)">
            <summary>
            Constructs the factory.
            </summary>
            <remarks>
            For the serialization of reliable messages is used <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            </remarks>
            <param name="acknowledgeTimeout">The maximum time until the delivery of the message must be acknowledged.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.#ctor(System.TimeSpan,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory.
            </summary>
            <param name="acknowledgeTimeout">The maximum time until the delivery of the message must be acknowledged.</param>
            <param name="serializer">Serializer used to serialize messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageSender``2">
            <summary>
            Creates the reliable message sender.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory.CreateReliableDuplexTypedMessageReceiver``2">
            <summary>
            Creates the reliable message receiver.
            </summary>
            <typeparam name="_ResponseType">type of response message</typeparam>
            <typeparam name="_RequestType">type of request message</typeparam>
            <returns>reliable typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed reliable message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of the specified type.
            In addition it provides events notifying whether the respone message was delivered.
            The reliable typed message receiver can be used only with the reliable typed message sender.
            </summary>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the typed response message.
            </summary>
            <param name="responseReceiverId">identifies the response receiver</param>
            <param name="responseMessage">respone message</param>
            <returns>id of the message. The id can be then used to check if the message was received.</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when the reliable typed message sender opened connection.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the reliable typed message sender was disconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageDelivered">
            <summary>
            The event is invoked when the response message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageReceiver`2.ResponseMessageNotDelivered">
            <summary>
            The event is invoked when the response message was not delivered within specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs">
            <summary>
            Declares the event type when the request message is received.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event from thr parameters.
            </summary>
            <param name="requestMessage"></param>
            <param name="responseReceiverId"></param>
            <param name="senderAddress"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.RequestMessage">
            <summary>
            Returns the request message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.ResponseReceiverId">
            <summary>
            Returns the response receiver id.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.StringMessages.StringRequestReceivedEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.SilverlightDispatching">
            <summary>
            Provides dispatcher that invokes incoming methods in the Silverlight thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.SilverlightDispatching.GetDispatcher">
            <summary>
            Returns dispatcher which invokes methods in the Silverlight thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Router.NamespaceDoc">
            <summary>
            Functionality for routing messages to a different address.
            </summary>
            <remarks>
            Router receives messages and routes them to a different preconfigured address.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.DefaultMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed reliable message sender.
            The reliable sender can send typed messages and receive typed response messages.
            In addition it provides events notifying whether the message was delivered.
            The reliable typed message sender can be used only with the reliable typed message receiver.
            </summary>
            <typeparam name="_ResponseType">type of the response message</typeparam>
            <typeparam name="_RequestType">type of the message</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the message to the reliable typed message receiver.
            </summary>
            <param name="message">message to be sent</param>
            <returns>id of the message. The id can be then used to check if the message was received.</returns>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
            <remarks>
            Notice, the event is raised in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when the response message is received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageDelivered">
            <summary>
            The event is invoked when the message was delivered.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IReliableTypedMessageSender`2.MessageNotDelivered">
            <summary>
            The event is invoked if the event is not delivered within a specified time.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.NamespaceDoc">
            <summary>
            Communication using remote procedure calls.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Streaming.DynamicStream">
            <summary>
            Implements the stream that can be written and read at the same time.
            </summary>
            <remarks>
            The dynamic stream supports writing of data by one thread and reading by another.
            The reading operation is blocked until the requested amount of data is not available.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Flush">
            <summary>
            The Flush is not applicable. If called, it does nothing.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            The stream does not support Seek.
            It throws NotSupportedException.
            </summary>
            <param name="offset">not applicable</param>
            <param name="origin">not applicable</param>
            <returns>not applicable</returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.SetLength(System.Int64)">
            <summary>
            The stream does not support SetLength.
            It throws NotSupportedException.
            </summary>
            <param name="value">not applicable</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads data from the stream to the specified buffer.
            </summary>
            <remarks>
            If the requested amount of data is not available the thread is blocked until required amount of data
            is available - until data is written by another thread.
            </remarks>
            <param name="buffer">The buffer where the data will be written.</param>
            <param name="offset">Starting position in the buffer where data will be wqritten.</param>
            <param name="count">Requested amount of data to be read.</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the data to the stream.
            </summary>
            <param name="buffer">Buffer to be written to the stream</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.WriteWithoutCopying(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes data to the stream the way that it just stores the reference to the input data.
            </summary>
            <remarks>
            It does not copyt the incoming data to the stream but instead of that it just stores the reference.
            This approach is very fast but the input byte[] array should not be modified after calling this method.
            </remarks>
            <param name="data">data to be written to the stream.</param>
            <param name="offset">Starting podition in the buffer from where data will be read.</param>
            <param name="count">Amount of data to be read from the buffer and written to the stream.</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Close">
            <summary>
            Closes the stream and releases the reading thread waiting for data.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.myMessageQueue">
            <summary>
            The writing puts the byte sequences to the queue as they come.
            The reading removes the sequences of bytes from the queue.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.IsBlockingMode">
            <summary>
            Gets or sets the blocking mode. If blocking mode then Read method blocks until data is available.
            </summary>
            <remarks>
            If blocking mode then Read method blocks until data is available. If unblocking mode is set then
            Read method reads available data and returns. If a reading thread is blocked (waiting) and the unblocking mode
            is set the thread is released.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanRead">
            <summary>
            Returns true, because the stream supports reading.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanSeek">
            <summary>
            Returns false, because the stream does not support Seek.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.CanWrite">
            <summary>
            Returns true, because the stream supports writing.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Length">
            <summary>
            Returns always 0.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.DataProcessing.Streaming.DynamicStream.Position">
            <summary>
            'Get' returns always 0. Set does nothing.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.NamespaceDoc">
            <summary>
            Functionality for the component forwarding messages to all attached receivers.
            </summary>
            <remarks>
            Receives messages and forwards them to all attached receivers.
            The message is then processed by more services in parallel.
            E.g. If a client needs to evaluate results from more different services.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory">
            <summary>
            Implements the factory to create the connection provider. The connection provider
            helps to attach a channel to a component or to connect two components with a channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Infrastructure.ConnectionProvider.ConnectionProviderFactory.CreateConnectionProvider(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Creates the connection provider.
            </summary>
            <param name="messagingSystem">Messaging system the connection provider will use to create channels.</param>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory">
            <summary>
            The interface declares the factory that creates message senders and receivers.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender that can send request messages and receive response
            messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of request messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates synchronous duplex typed message sender that sends a request message and then
            waits until the response message is received.
            </summary>
            <typeparam name="_ResponseType">Response message type.</typeparam>
            <typeparam name="_RequestType">Request message type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver that can receive request messages and
            send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory">
            <summary>
            Implements the factory to create the bidirectional dispatcher.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory">
            <summary>
            Declares the factory to create the bidirectional dispatcher.
            </summary>
            <remarks>
            The bidirectional dispatcher sends messages to all duplex output channels and also can route back response messages.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.IDuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the duplex dispatcher factory.
            </summary>
            <param name="duplexOutputChannelsFactory">
            the messaging system factory used to create duplex output channels
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Dispatcher.DuplexDispatcherFactory.CreateDuplexDispatcher">
            <summary>
            Creates the duplex dispatcher.
            </summary>
            <returns>duplex dispatcher</returns>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory">
            <summary>
            Declares the factory to create the broker and the broker client.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.IDuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.HttpMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages via HTTP.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper">
            <summary>
            Declares the duplex channel unwrapper.
            </summary>
            <remarks>
            The duplex channel wrapper is listening to more duplex input channels. When it receives some message,
            it wraps the message and sends it via the only duplex output channel.
            On the other side the message is received by duplex channel unwrapper. The unwrapper unwraps the message
            and uses the duplex output channel to forward the message to the correct receiver.<br/>
            The receiver can also send the response message. Then it goes the same way back.<br/>
            Notice, the 'duplex channel unwrapper' can communication only with 'duplex channel wrapper'.
            It cannot communicate with one-way 'channel wrapper'.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.GetAssociatedResponseReceiverId(System.String)">
            <summary>
            Returns response receiver id of the client connected to the unwrapper.
            </summary>
            <param name="responseReceiverId">responseRecieverId from unwrapped message</param>
            <returns>responseReceiverId of the client connected to the channel unwrapper. Returns null if it does not exist.</returns>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverConnected">
            <summary>
            The event is invoked when the duplex channel wrapper opened the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.Nodes.ChannelWrapper.IDuplexChannelUnwrapper.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when the duplex channel wrapper closed the connection with this
            unwrapper via its duplex output channel.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseReceiverDisconnected(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.ResponseReceiverEventArgs)">
            <summary>
            The method is called when the response receiver is disconnected.
            The method clears all connections related to the disconnected receiver.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.ChannelWrapper.DuplexChannelUnwrapper.OnResponseMessageReceived(System.Object,Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs)">
            <summary>
            Method is called when a response is received from the duplex output channel.
            It wrapps the response and sends the wrapped response to the correct response receiver as the response.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider">
            <summary>
            The interface declares the default functionality to send and receive messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.SendMessage(System.String,System.Object)">
            <summary>
            Sends the message to desired receiver.
            </summary>
            <param name="receiverId"></param>
            <param name="message"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.RegisterMessageHandler(System.String,System.Action{System.Object})">
            <summary>
            Registers the method handling the message.
            </summary>
            <param name="receiverId"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.SimpleMessagingSystemBase.IMessagingProvider.UnregisterMessageHandler(System.String)">
            <summary>
            Unregisters the handler.
            </summary>
            <param name="receiverId"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory">
            <summary>
            Extends the communication by the buffered messaging and the network connection monitoring.
            </summary>
            <remarks>
            This is the composite messaging system that consist of:
            <ol>
            <li>Buffered Messaging  --&gt; buffering messages if disconnected (while automatically trying to reconnect)</li>
            <li>Monitored Messaging --&gt; constantly monitoring the connection</li>
            <li>Messaging System    --&gt; responsible for sending and receiving messages</li>
            </ol>
            The buffer stores messages if the connection is not open. The connection monitor constantly checks if the connection
            is established. See also <see cref="T:Eneter.Messaging.MessagingSystems.Composites.BufferedMessagingComposit.BufferedMessagingFactory"/> and <see cref="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitoredMessagingFactory"/>.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory)">
            <summary>
            Constructs the factory with default settings.
            </summary>
            <remarks>
            The serializer for the 'ping' messages checking the connection is set to <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>.
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system e.g. HTTP, TCP, ...</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <remarks>
            The maximum offline time is set to 10 seconds.
            The duplex output channel will check the connection with the 'ping' once per second and the response must be received within 2 seconds.
            Otherwise the connection is closed.<br/>
            The duplex input channel expects the 'ping' request at least once per 2 seconds. Otherwise the duplex output
            channel is disconnected.
            </remarks>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory,Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.TimeSpan,System.TimeSpan,System.TimeSpan)">
            <summary>
            Constructs the factory with the specified parameters.
            </summary>
            <param name="underlyingMessaging">underlying messaging system</param>
            <param name="serializer">serializer used to serialize the 'ping' requests</param>
            <param name="maxOfflineTime">the maximum time, the messaging can work offline. When the messaging works offline,
            the sent messages are buffered and the connection is being reopened. If the connection is
            not reopen within maxOfflineTime, the connection is closed.
            </param>
            <param name="pingFrequency">how often the connection is checked with the 'ping' requests.</param>
            <param name="pingResponseTimeout">the maximum time, the response for the 'ping' is expected.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex output channel <see cref="!:ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages.
            </summary>
            <remarks>
            This duplex output channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the connection is available. It sends 'ping' requests and expects 'ping' responses
            within the specified time. If the 'ping' response does not come, the buffered messaging layer is notified,
            that the connection was interrupted.
            The buffered messaging then tries to reconnect and stores sent messages to the buffer.
            If the connection is open, the buffered messages are sent.
            If the reconnection was not successful, it notifies <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel.ConnectionClosed"/>
            and deletes messages from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <param name="responseReceiverId">the unique id of this response receiver</param>
            <returns>composit duplex output channel <see cref="!:ICompositeDuplexOutputChannel"/></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.BufferedMonitoredMessagingFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending the response messages.
            </summary>
            <remarks>
            This duplex input channel provides the buffered messaging and the connection monitoring.
            The channel regularly checks if the duplex output channel is still connected. It expect, that every connected duplex output channel
            sends regularly 'ping' messages. If the 'ping' message from the duplex output channel is not received within the specified
            time, the duplex output channel is disconnected and the buffered messaging (as the layer above) is notified about the
            disconnection.
            The buffered messaging then puts all sent response messages to the buffer and waits whether the duplex output channel reconnects.
            If the duplex output channel reopens the connection, the buffered response messages are sent.
            If the duplex output channel does not reconnect, the event
            <see cref="E:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexInputChannel.ResponseReceiverDisconnected"/> is invoked and rsponse messages are deleted from the buffer.
            </remarks>
            <param name="channelId">channel id, the syntax of the channel id must comply to underlying messaging</param>
            <returns>composit duplex input channel with the buffer <see cref="!:ICompositeDuplexInputChannel"/></returns>
        </member>
        <member name="T:Eneter.Messaging.Infrastructure.ConnectionProvider.NamespaceDoc">
            <summary>
            Helper functionality to create and attach channels to components.
            </summary>
            <remarks>
            This connecting functionality helps to reduce the amount of coding. It connects communicating components with channels.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2">
            <summary>
            The interface declares the strongly typed duplex message receiver.
            The receiver is able to receive messages of the specified type and send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">The type of sending response messages.</typeparam>
            <typeparam name="_RequestType">The type of receiving messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.SendResponseMessage(System.String,`0)">
            <summary>
            Sends the response message back to the duplex typed message sender via the attached duplex input channel.
            </summary>
            <param name="responseReceiverId">identifies the duplex typed message sender that will receive the response</param>
            <param name="responseMessage">response message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.MessageReceived">
            <summary>
            The event is invoked when the message from a duplex typed message sender was received.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverConnected">
            <summary>
            The event is invoked when a duplex typed message sender opened the connection via its duplex output channel.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageReceiver`2.ResponseReceiverDisconnected">
            <summary>
            The event is invoked when a duplex typed message sender closed the connection via its duplex output channel.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.Rpc.IRpcFactory">
            <summary>
            Declares factory which can create RPC clients and services. 
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateClient``1">
            <summary>
            Creates the client for the given interface.
            </summary>
            <typeparam name="TServiceInterface">interface type declaring methods and events that shall be used for
            the interprocess communication</typeparam>
            <returns>RPC client component</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.Rpc.IRpcFactory.CreateService``1(``0)">
            <summary>
            Creates the service which implements the given interface.
            </summary>
            <typeparam name="TServiceInterface">interface type declaring methods and events which are exposed via the service</typeparam>
            <param name="service">instance implementing the service interface</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.ErrorHandler">
            <summary>
            Internal helper class to trace typical messags.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Serialize``1(``0,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Output bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <param name="algorithm">algorithm used to encrypt the serialized data</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.CryptoSerializerProvider.Deserialize``1(System.Object,System.Security.Cryptography.SymmetricAlgorithm)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <param name="algorithm">algorithm used to decrypt data before deserialization</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.AesSerializer">
            <summary>
            Serializer using AES (Advanced Encryption Standard).
            </summary>
            <remarks>
            The serializer uses an underlying serializer to serialize and deserialize data.
            Data encoded by the underlying serializer is then encrypted by AES.
            <example>
            Encrypted serialization with <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/>
            <code>
            // Create the serializer. The defualt constructor uses XmlStringSerializer.
            AesSerializer aSerializer = new AesSerializer("My password.");
            
            // Create some data to be serialized.
            MyData aData = new MyData();
            ...
            
            // Serialize data with using AES.
            object aSerializedData = aSerializer.Serialize&lt;MyData&gt;(aData);
            </code>
            </example>
            <br/><br/>
            Notice, since AesSerializer serializes into array of bytes, it is not possible to use this serializer
            for the communication between two Silverlight applications. The communication between two silverlight applications
            requires, that data is serialized into the string.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String)">
            <summary>
            Constructs the serializer. It uses <see cref="T:Eneter.Messaging.DataProcessing.Serializing.XmlStringSerializer"/> as the underlying serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate 128 bit key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.String,System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="password">password used to generate the key</param>
            <param name="salt">additional value used to calculate the key</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="keyBitSize">bit size of the key e.g. 128, 256</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer,System.Security.Cryptography.DeriveBytes,System.Int32)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
            <param name="passwordBasedKeyGenerator">generator of key from the password</param>
            <param name="keyBitSize">bit size of the key</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.#ctor(System.Byte[],System.Byte[],Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the serializer.
            </summary>
            <param name="key">key</param>
            <param name="iv">initialization vector</param>
            <param name="underlyingSerializer">underlying serializer (e.g. XmlStringSerializer or BinarySerializer)</param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Serialize``1(``0)">
            <summary>
            Serializes data to the object.
            The returned object is type of byte[]. Returned bytes are encrypted.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="dataToSerialize">Data to be serialized.</param>
            <returns>Data serialized in byte[].</returns>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.Serializing.AesSerializer.Deserialize``1(System.Object)">
            <summary>
            Deserializes data into the specified type.
            </summary>
            <typeparam name="_T">Type of serialized data.</typeparam>
            <param name="serializedData">Encrypted data to be deserialized.</param>
            <returns>Deserialized object.</returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NamespaceDoc">
            <summary>
            Routing messages according to specified threading model.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.NoDispatching">
            <summary>
            Provides dispatcher that just invokes the method directly from the calling thread.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.NoDispatching.GetDispatcher">
            <summary>
            Returns dispatcher invoking the method directly from the calling thread.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.Threading.Dispatching.AsyncDispatching">
            <summary>
            Provides dispatcher that invokes methods asynchronously using ThreadPool.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Threading.Dispatching.AsyncDispatching.GetDispatcher">
            <summary>
            Returns dispatcher that invokes methods using TrheadPool.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter">
            <summary>
            Implements encoding/decoding of low-level messages into eneter format.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String)">
            <summary>
            Encodes open connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeOpenConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'open connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String)">
            <summary>
            Encodes close connection request.
            </summary>
            <param name="responseReceiverId">client id</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeCloseConnectionMessage(System.String,System.IO.Stream)">
            <summary>
            Encodes 'close connection' message directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object)">
            <summary>
            Encodes a message or a response message.
            </summary>
            <param name="responseReceiverId">client id</param>
            <param name="message">the serialized content of the message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.EncodeMessage(System.String,System.Object,System.IO.Stream)">
            <summary>
            Encodes 'request message' or 'response message' directly to the stream.
            </summary>
            <param name="responseReceiverId"></param>
            <param name="message"></param>
            <param name="outputSream"></param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.IO.Stream)">
            <summary>
            Decodes a message or a response message from the stream.
            </summary>
            <param name="readStream">stream containing the low-level message</param>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ConnectionProtocols.EneterProtocolFormatter.DecodeMessage(System.Byte[])">
            <summary>
            Decodes a message or a response message from the byte[].
            </summary>
            <param name="readMessage">source of the low-level message</param>
            <returns></returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage">
            <summary>
            Internal message used by Eneter framework for reliable communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor">
            <summary>
            Default constructor for serializing purposes.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor(System.String)">
            <summary>
            Constructs the acknowledge message.
            Acknowledge confirms, the message was delivered.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.#ctor(System.String,System.Object)">
            <summary>
            Constructs the reliable message that contains the message to be sent.
            </summary>
            <param name="messageId"></param>
            <param name="message"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.MessageType">
            <summary>
            Type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.MessageId">
            <summary>
            In case of the message type Message - unique id of the reliable message.
            In case of the message type Acknowledge - id of the message, that is acknowledged.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.Message">
            <summary>
            In case of the message type Message - the message that shall be sent reliably.
            In case of the message type Acknowledge - not used.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType">
            <summary>
            Indicates the purpose of the message.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType.Message">
            <summary>
            The reliable message contains a message that shall be notified via the event.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.EndPoints.TypedMessages.ReliableMessage.EMessageType.Acknowledge">
            <summary>
            The reliable message is the acknowledgement, that the message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2">
            <summary>
            The interface declares the strongly typed duplex message sender.
            The duplex sender is able to send messages of the specified type and receive responses of the specified type.
            </summary>
            <typeparam name="_ResponseType">The type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">The type of sending messages.</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.SendRequestMessage(`1)">
            <summary>
            Sends the strongly typed message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
            <remarks>
            Notice, the event is raised in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.TypedMessages.IDuplexTypedMessageSender`2.ResponseReceived">
            <summary>
            The event is invoked when a response message was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs">
            <summary>
            The event arguments of the received message from the broker.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.String,System.Object)">
            <summary>
            Constructs the event from the input parameters.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.#ctor(System.Exception)">
            <summary>
            Constructs the event from the error detected during receiving of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.MessageTypeId">
            <summary>
            Returns type of the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.Nodes.Broker.BrokerMessageReceivedEventArgs.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory">
            <summary>
            Implements the messaging system delivering messages to the particular working thread.
            </summary>
            <remarks>
            Each input channel is represented by its own working thread removing messages from the queue and processing them
            one by one.
            <br/><br/>
            Different instances of ThreadMessagingSystemFactory are independent and so they
            are different messaging systems. Therefore if you want to send/receive a message with this messaging system
            then output and input channels must be created by the same instance of ThreadMessagingSystemFactory.
            <br/><br/>
            Notice, the messages are always received in one particular working thread, but the notification events e.g. connection opened
            are invoked in a different thread.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.#ctor(Eneter.Messaging.MessagingSystems.ConnectionProtocols.IProtocolFormatter)">
            <summary>
            Constructs thread based messaging factory.
            </summary>
            <remarks>
            Every instance of the synchronous messaging system factory represents one messaging system.
            It means that two instances of this factory class creates channels for two independent (differnt) messaging system.
            </remarks>
            <param name="protocolFormatter">low-level message formatter for the communication between channels.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method generates the unique response receiver id automatically.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexOutputChannel(System.String,System.String)">
            <summary>
            Creates the duplex output channel sending messages to the duplex input channel and receiving response messages by using the working thread.
            </summary>
            <remarks>
            The duplex output channel is intended for the bidirectional communication.
            Therefore, it can send messages to the duplex input channel and receive response messages.
            <br/><br/>
            The duplex input channel distinguishes duplex output channels according to the response receiver id.
            This method allows to specified a desired response receiver id. Please notice, the response receiver
            id is supposed to be unique.
            <br/><br/>
            The duplex output channel can communicate only with the duplex input channel and not with the input channel.
            </remarks>
            <param name="channelId">Identifies the receiving duplex input channel.</param>
            <param name="responseReceiverId">Identifies the response receiver of this duplex output channel.</param>
            <returns>duplex output channel</returns>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.CreateDuplexInputChannel(System.String)">
            <summary>
            Creates the duplex input channel receiving messages from the duplex output channel and sending back response messages by using the working thread.
            </summary>
            <remarks>
            The duplex input channel is intended for the bidirectional communication.
            It can receive messages from the duplex output channel and send back response messages.
            <br/><br/>
            The duplex input channel can communicate only with the duplex output channel and not with the output channel.
            </remarks>
            <param name="channelId">Identifies this duplex input channel.</param>
            <returns>duplex input channel</returns>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.InputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex input channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that all messages from all connected clients are routed by one working thread.
            </remarks>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.ThreadMessagingSystem.ThreadMessagingSystemFactory.OutputChannelThreading">
            <summary>
            Factory that will create dispatchers responsible for routing events from duplex output channel according to
            desired threading strategy.
            </summary>
            <remarks>
            Default setting is that received response messages are routed via one working thread.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.NamespaceDoc">
            <summary>
            Functionality extending the default behavior of messaging systems.
            </summary>
            <remarks>
            E.g.: Buffering of sent messages, or network connection monitoring.<br/>
            The composite is a messaging system derived from
            <see cref="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.IMessagingSystemFactory"/> and implements the extending functionality.
            It means, e.g. if you wish to buffer sent messages during the disconnection,
            you can create the buffered messaging system.
            <example>
            Creating of the buffered messaging using the TCP as the underlying messaging system.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory anUnderlyingMessaging = new TcpMessagingSystemFactory();
            
            // Create the buffered messaging using TCP as the underlying messaging.
            IMessagingSystemFactory aBufferedMessaging = new BufferedMessagingFactory(anUnderlyingMessaging);
            </code>
            </example>
            Creating buffered messaging that internally uses monitored messaging constantly monitoring the connection.
            <example>
            Creating the TCP based messaging system constantly checking the network connection and providing the buffer
            for sent messages in case of the disconnection.
            <code>
            // Create TCP messaging system.
            IMessagingSystemFactory aTcpMessaging = new TcpMessagingSystemFactory();
            
            // Create the composite providing the network connection monitor.
            IMessagingSystemFactory aMonitoredMessaging = new MonitoredMessagingFactory(aTcpMessaging);
            
            // Create the composite providing the buffer used for the sent messages in case of the disconnection.
            IMessagingSystemFactory aBufferedMonitoredMessaging = new BufferedMessagingFactory(aMonitoredMessaging);
            
            
            ...
            
            // Create the duplex output channel, that monitores the network connection and buffers sent messages if disconnected.
            IDuplexOutputChannel aDuplexOutputChannel = aBufferedMonitoredMessaging.CreateDuplexOutputChannel("tcp://127.0.0.1:6080/");
            
            </code>
            </example>
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.NamespaceDoc">
            <summary>
            Sending and receiving messages as typed data. E.g. you may want that the request message is type of YourRequest and the response message
            is type of YourResponse.
            </summary>
            <example>
            For more details see examples:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory"/> - sending and receiving messages of declared type.</li>
                <li><see cref="T:Eneter.Messaging.EndPoints.TypedMessages.ReliableTypedMessagesFactory"/> - sending and receiving messages of declared typed and receiving information
                    if the message was delivered or not.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1">
            <summary>
            The event when the typed message is received.
            </summary>
            <typeparam name="_RequestMessageType"></typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="requestMessage">message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructs the message from the exception.
            </summary>
            <param name="responseReceiverId">identifies the client where the response can be sent</param>
            <param name="senderAddress">address of the message sender. It is null if not applicable for the messaging system.</param>
            <param name="error">error detected during receiving the message</param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.RequestMessage">
            <summary>
            Returns the received message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ResponseReceiverId">
            <summary>
            Returns the client identifier where the response can be sent.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedRequestReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns the error detected during receiving of the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory">
            <summary>
            Implements the factory to create duplex strongly typed message sender and receiver.
            </summary>
            <remarks>
            
            <example>
            Simple service listening to request messages of type 'RequestMessage' and responding the response message of type 'ResponseMessage'.
            <code>
            using System;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorService
            {
                // Request message.
                public class RequestMessage
                {
                    public int Number1 { get; set; }
                    public int Number2 { get; set; }
                }
            
                // Response message.
                public class ResponseMessage
                {
                    public int Result { get; set; }
                }
            
                class Program
                {
                    static void Main(string[] args)
                    {
                        // Create message receiver.
                        IDuplexTypedMessagesFactory aReceiverFactory = new DuplexTypedMessagesFactory();
                        IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt; aReceiver =
                            aReceiverFactory.CreateDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to process request messages.
                        aReceiver.MessageReceived += OnMessageReceived;
            
                        // Use WebSocket for the communication.
                        // Note: You can also other messagings. E.g. TcpMessagingSystemFactory
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aMessaging.CreateDuplexInputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the input channel to the receiver and start listening.
                        aReceiver.AttachDuplexInputChannel(anInputChannel);
            
                        Console.WriteLine("The calculator service is running. Press ENTER to stop.");
                        Console.ReadLine();
            
                        // Detach the input channel to stop listening.
                        aReceiver.DetachDuplexInputChannel();
                    }
            
                    private static void OnMessageReceived(object sender, TypedRequestReceivedEventArgs&lt;RequestMessage&gt; e)
                    {
                        // Calculate numbers.
                        ResponseMessage aResponseMessage = new ResponseMessage();
                        aResponseMessage.Result = e.RequestMessage.Number1 + e.RequestMessage.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", e.RequestMessage.Number1, e.RequestMessage.Number2, aResponseMessage.Result);
            
                        // Send back the response message.
                        var aReceiver = (IDuplexTypedMessageReceiver&lt;ResponseMessage, RequestMessage&gt;)sender;
                        aReceiver.SendResponseMessage(e.ResponseReceiverId, aResponseMessage);
                    }
                }
            }
            
            </code>
            </example>
            
            <example>
            Simple client sending request messages of type 'RequestMessage' and receiving responses of type 'ResponseMessage'.
            The client is synchronous. It sends the request message and waits for the response.
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClientSync
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private ISyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateSyncDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        ResponseMessage aResponse = mySender.SendRequestMessage(aRequest);
            
                        // Display the result.
                        ResultTextBox.Text = aResponse.Result.ToString();
                    }
                }
            }
            </code>
            </example>
            
            <example>
            Simple client sending request messages of type 'RequestMessage' and receiving responses of type 'ResponseMessage'.
            The client receives the response asynchronously via the event.
            <code>
            using System;
            using System.Windows.Forms;
            using Eneter.Messaging.EndPoints.TypedMessages;
            using Eneter.Messaging.MessagingSystems.MessagingSystemBase;
            using Eneter.Messaging.MessagingSystems.WebSocketMessagingSystem;
            
            namespace CalculatorClient
            {
                public partial class Form1 : Form
                {
                    // Request message.
                    public class RequestMessage
                    {
                        public int Number1 { get; set; }
                        public int Number2 { get; set; }
                    }
            
                    // Response message.
                    public class ResponseMessage
                    {
                        public int Result { get; set; }
                    }
            
                    private IDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt; mySender;
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        OpenConnection();
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        CloseConnection();
                    }
            
            
                    private void OpenConnection()
                    {
                        // Create the message sender.
                        IDuplexTypedMessagesFactory aSenderFactory = new DuplexTypedMessagesFactory();
                        mySender = aSenderFactory.CreateDuplexTypedMessageSender&lt;ResponseMessage, RequestMessage&gt;();
            
                        // Subscribe to receive response messages.
                        mySender.ResponseReceived += OnResponseReceived;
            
                        // Use Websocket for the communication.
                        // If you want to use TCP then use TcpMessagingSystemFactory().
                        IMessagingSystemFactory aMessaging = new WebSocketMessagingSystemFactory();
                        IDuplexOutputChannel anOutputChannel = aMessaging.CreateDuplexOutputChannel("ws://192.168.1.102:8099/aaa/");
            
                        // Attach the output channel and be able to send messages
                        // and receive response messages.
                        mySender.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void CloseConnection()
                    {
                        // Detach input channel and stop listening to response messages.
                        mySender.DetachDuplexOutputChannel();
                    }
            
                    private void CalculateBtn_Click(object sender, EventArgs e)
                    {
                        // Create the request message.
                        RequestMessage aRequest = new RequestMessage();
                        aRequest.Number1 = int.Parse(Number1TextBox.Text);
                        aRequest.Number2 = int.Parse(Number2TextBox.Text);
            
                        // Send request to the service to calculate 2 numbers.
                        mySender.SendRequestMessage(aRequest);
                    }
            
                    private void OnResponseReceived(object sender, TypedResponseReceivedEventArgs&lt;ResponseMessage&gt; e)
                    {
                        // Display the result using the UI thread.
                        UI(() =&gt; ResultTextBox.Text = e.ResponseMessage.Result.ToString());
                    }
            
                    // Helper method to invoke a delegate in the UI thread.
                    // Note: You can manipulate UI controls only from the UI tread.
                    private void UI(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action();
                        }
                    }
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor">
            <summary>
            Constructs the factory with xml serializer. <br/>
            </summary>
            <remarks>
            The factory will create senders and receivers with the default XmlStringSerializer<br/>
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified serializer.
            </summary>
            <remarks>
            The factory will create senders and receivers with the specified serializer
            and the factory will create ISyncDuplexTypedMessageSender that can wait infinite
            time for the response message from the service.<br/>
            <br/>
            For possible serializers you can refer to <see cref="N:Eneter.Messaging.DataProcessing.Serializing"/>
            </remarks>
            <param name="serializer">Serializer used to serialize request and response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan)">
            <summary>
            Constructs the factory with specified timeout for ISyncDuplexTypedMessageSender.
            </summary>
            <remarks>
            The factory will create senders and receivers using the default XmlStringSerializer
            and the factory will create ISyncDuplexTypedMessageSender with specified timeout
            indicating how long it can wait for a response message from the service.
            </remarks>
            <param name="syncResponseReceiveTimeout">Timeout specifying the maximum time
            the ISyncDuplexTypedMessageSender will wait for the response message from the service.
            </param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.#ctor(System.TimeSpan,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the factory with specified timeout for synchronous message sender and
            specified serializer.
            </summary>
            <param name="syncResponseReceiveTimeout">Timeout specifying the maximum time
            the ISyncDuplexTypedMessageSender will wait for the response message from the service.
            </param>
            <param name="serializer">Serializer used to serialize request and response messages.</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageSender``2">
            <summary>
            Creates duplex typed message sender that can send request messages and receive response
            messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of receiving response messages.</typeparam>
            <typeparam name="_RequestType">Type of sending messages.</typeparam>
            <returns>duplex typed message sender</returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateSyncDuplexTypedMessageSender``2">
            <summary>
            Creates synchronous duplex typed message sender that sends a request message and then
            waits until the response message is received.
            </summary>
            <typeparam name="_ResponseType">Response message type.</typeparam>
            <typeparam name="_RequestType">Request message type.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.DuplexTypedMessagesFactory.CreateDuplexTypedMessageReceiver``2">
            <summary>
            Creates duplex typed message receiver that can receive request messages and
            send back response messages of specified type.
            </summary>
            <typeparam name="_ResponseType">Type of response messages.</typeparam>
            <typeparam name="_RequestType">Type of receiving messages.</typeparam>
            <returns>duplex typed message receiver</returns>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1">
            <summary>
            The event when a typed response message is received.
            </summary>
            <typeparam name="_ResponseMessageType">message type</typeparam>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the event.
            </summary>
            <param name="responseMessage">response message</param>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.#ctor(System.Exception)">
            <summary>
            Constructs the event from the exception detected during receiving the response message.
            </summary>
            <param name="error"></param>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ResponseMessage">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.EndPoints.TypedMessages.TypedResponseReceivedEventArgs`1.ReceivingError">
            <summary>
            Returns an exception detected during receiving the response message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender">
            <summary>
            The interface declares the duplex string message sender.
            The duplex sender is able to send text messages and receive text responses.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.SendMessage(System.String)">
            <summary>
            Sends the message via the attached duplex output channel.
            </summary>
            <param name="message">message</param>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionOpened">
            <summary>
            The event is raised when the connection with the receiver is open.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ConnectionClosed">
            <summary>
            The event is raised when the connection with the receiver is closed.
            </summary>
            <remarks>
            Notice, the event is invoked in a thread from the thread pool. Therefore, if you need to manipulate UI,
            do not forget to marshal it to the UI thread.
            </remarks>
        </member>
        <member name="E:Eneter.Messaging.EndPoints.StringMessages.IDuplexStringMessageSender.ResponseReceived">
            <summary>
            The event is raised when a response message from duplex string message receiver was received.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.Serializing.NamespaceDoc">
            <summary>
            Functionality to serialize or deserialize messages or data.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.ChannelWrapper.NamespaceDoc">
            <summary>
            Functionality for sending/receiving more message types via one channel.
            </summary>
            <remarks>
            The channel wrapper and unwrapper are components allowing to send/receive different types of messages via one channel.
            E.g. to send and receive multiple types of request messages via one IP address and port.
            <example>
            Simple service using the channel unwrapper to receive all request messages via one IP address and port.
            <code>
            namespace ServerCalculator2
            {
                // Input data for calculator requests
                public class CalculatorInputData
                {
                    public double Number1 { get; set; }
                    public double Number2 { get; set; }
                }
            
                // Output result from the calculator
                public class CalculatorOutputData
                {
                    public double Result { get; set; }
                }
            
                internal class Calculator
                {
                    public Calculator()
                    {
                        // Internal messaging used for messaging between channel unwrapper
                        // and typed message receivers.
                        // We want that requests do not block each other. So every request will be processed in its own thread.
                        IMessagingSystemFactory anInternalMessaging = new ThreadPoolMessagingSystemFactory();
            
                        // All messages are received via one channel. So we must provide "unwrapper" forwarding incoming messages
                        // to correct receivers.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelUnwrapper = aChannelWrapperFactory.CreateDuplexChannelUnwrapper(anInternalMessaging);
            
                        // To connect receivers and the unwrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        // Factory to create message receivers.
                        IDuplexTypedMessagesFactory aMessageReceiverFactory = new DuplexTypedMessagesFactory();
                        
                        // Create receiver to sum two numbers.
                        mySumReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumReceiver.MessageReceived += SumCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySumReceiver, "Sum"); // attach the input channel to get messages from unwrapper
            
                        // Receiver to subtract two numbers.
                        mySubtractReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubtractReceiver.MessageReceived += SubCmd; // attach method handling the request
                        aConnectionProvider.Attach(mySubtractReceiver, "Sub"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for multiply two numbers.
                        myMultiplyReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMultiplyReceiver.MessageReceived += MulCmd; // attach method handling the request
                        aConnectionProvider.Attach(myMultiplyReceiver, "Mul"); // attach the input channel to get messages from unwrapper
            
                        // Receiver for divide two numbers.
                        myDivideReceiver = aMessageReceiverFactory.CreateDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivideReceiver.MessageReceived += DivCmd; // attach method handling the request
                        aConnectionProvider.Attach(myDivideReceiver, "Div"); // attach the input channel to get messages from unwrapper
                    }
            
            
                    public void Start()
                    {
                        // We use TCP based messaging.
                        IMessagingSystemFactory aServiceMessagingSystem = new TcpMessagingSystemFactory();
                        IDuplexInputChannel anInputChannel = aServiceMessagingSystem.CreateDuplexInputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the input channel to the unwrapper and start to listening.
                        myDuplexChannelUnwrapper.AttachDuplexInputChannel(anInputChannel);
                    }
            
                    public void Stop()
                    {
                        // Detach the input channel from the unwrapper and stop listening.
                        // Note: It releases listening threads.
                        myDuplexChannelUnwrapper.DetachDuplexInputChannel();
                    }
            
                    // It is called when a request to sum two numbers was received.
                    private void SumCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 + anInputData.Number2;
            
                        Console.WriteLine("{0} + {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySumReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to subtract two numbers was received.
                    private void SubCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 - anInputData.Number2;
            
                        Console.WriteLine("{0} - {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        mySubtractReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // It is called when a request to multiply two numbers was received.
                    private void MulCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 * anInputData.Number2;
            
                        Console.WriteLine("{0} x {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myMultiplyReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
            
                    // It is called when a request to divide two numbers was received.
                    private void DivCmd(object sender, TypedRequestReceivedEventArgs&lt;CalculatorInputData&gt; e)
                    {
                        // Get input data.
                        CalculatorInputData anInputData = e.RequestMessage;
            
                        // Calculate output result.
                        CalculatorOutputData aReturn = new CalculatorOutputData();
                        aReturn.Result = anInputData.Number1 / anInputData.Number2;
            
                        Console.WriteLine("{0} / {1} = {2}", anInputData.Number1, anInputData.Number2, aReturn.Result);
            
                        // Response result to the client.
                        myDivideReceiver.SendResponseMessage(e.ResponseReceiverId, aReturn);
                    }
                    
            
                    // Unwrapps messages from the input channel and forwards them
                    // to corresponding output channels.
                    private IDuplexChannelUnwrapper myDuplexChannelUnwrapper;
            
                    // Paticular services listening to requests which will be forwarded from
                    // the channel unwrapper.
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySumReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; mySubtractReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myMultiplyReceiver;
                    private IDuplexTypedMessageReceiver&lt;CalculatorOutputData, CalculatorInputData&gt; myDivideReceiver;
                }
            }
            </code>
            </example>
            
            <example>
            Client using channel wrapper to send all request messages one IP address and port.
            <code>
            namespace CalculatorClient2
            {
                public partial class Form1 : Form
                {
                    // Input data for calculator requests
                    public class CalculatorInputData
                    {
                        public double Number1 { get; set; }
                        public double Number2 { get; set; }
                    }
            
                    // Output result from the calculator
                    public class CalculatorOutputData
                    {
                        public double Result { get; set; }
                    }
            
                    public Form1()
                    {
                        InitializeComponent();
            
                        // Internal messaging between message senders and channel wrapper.
                        IMessagingSystemFactory anInternalMessaging = new SynchronousMessagingSystemFactory();
            
                        // The service receives messages via one channel (i.e. it listens on one address).
                        // The incoming messages are unwrapped on the server side.
                        // Therefore the client must use wrapper to send messages via one channel.
                        IChannelWrapperFactory aChannelWrapperFactory = new ChannelWrapperFactory();
                        myDuplexChannelWrapper = aChannelWrapperFactory.CreateDuplexChannelWrapper();
            
            
                        // To connect message senders and the wrapper with duplex channels we can use the following helper class.
                        IConnectionProviderFactory aConnectionProviderFactory = new ConnectionProviderFactory();
                        IConnectionProvider aConnectionProvider = aConnectionProviderFactory.CreateConnectionProvider(anInternalMessaging);
            
                        
                        // Factory to create message senders.
                        // Sent messages will be serialized in Xml.
                        IDuplexTypedMessagesFactory aCommandsFactory = new DuplexTypedMessagesFactory();
            
                        // Sender to sum two numbers.
                        mySumSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySumSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySumSender, "Sum");
            
                        // Sender to subtract two numbers.
                        mySubSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        mySubSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, mySubSender, "Sub");
            
                        // Sender to multiply two numbers.
                        myMulSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myMulSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myMulSender, "Mul");
            
                        // Sender to divide two numbers.
                        myDivSender = aCommandsFactory.CreateDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt;();
                        myDivSender.ResponseReceived += OnResultResponse;
                        aConnectionProvider.Connect(myDuplexChannelWrapper, myDivSender, "Div");
            
                        // We use Tcp for the communication.
                        IMessagingSystemFactory aTcpMessagingSystem = new TcpMessagingSystemFactory();
            
                        // Create output channel to send requests to the service.
                        IDuplexOutputChannel anOutputChannel = aTcpMessagingSystem.CreateDuplexOutputChannel("tcp://127.0.0.1:8091/");
            
                        // Attach the output channel to the wrapper - so that we are able to send messages
                        // and receive response messages.
                        // Note: The service has the coresponding unwrapper.
                        myDuplexChannelWrapper.AttachDuplexOutputChannel(anOutputChannel);
                    }
            
                    private void Form1_FormClosed(object sender, FormClosedEventArgs e)
                    {
                        // Stop listening by detaching the input channel.
                        myDuplexChannelWrapper.DetachDuplexInputChannel();
                    }
            
            
                    private void OnResultResponse(object sender, TypedResponseReceivedEventArgs&lt;CalculatorOutputData&gt; e)
                    {
                        // If everything is ok then display the result.
                        if (e.ReceivingError == null)
                        {
                            // The response does not come in main UI thread.
                            // Therefore we must transfer it to the main UI thread.
                            InvokeInUIThread(() =&gt; ResultLabel.Text = e.ResponseMessage.Result.ToString() );
                        }
                    }
            
                    private void CalculateButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySumSender);
                    }
                     
                    private void SubtractButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(mySubSender);
                    }
            
                    private void MultiplyButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myMulSender);
                    }
            
                    private void DivideButton_Click(object sender, EventArgs e)
                    {
                        SendRequestMessage(myDivSender);
                    }
            
                    private void SendRequestMessage(IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; sender)
                    {
                        // Prepare input data for the calculator.
                        CalculatorInputData anInputForCalculator = new CalculatorInputData();
                        anInputForCalculator.Number1 = double.Parse(Number1TextBox.Text);
                        anInputForCalculator.Number2 = double.Parse(Number2TextBox.Text);
            
                        // Send the request message.
                        sender.SendRequestMessage(anInputForCalculator);
                    }
            
                    // Helper method to invoke UI always in the correct thread.
                    private void InvokeInUIThread(Action action)
                    {
                        if (InvokeRequired)
                        {
                            Invoke(action);
                        }
                        else
                        {
                            action.Invoke();
                        }
                    }
            
                    // Wraps requests into one output channel.
                    // The service side listens to one address and uses unwrapper to unwrap
                    // messages and send them to correct receivers.
                    private IDuplexChannelWrapper myDuplexChannelWrapper;
            
                    // Message senders.
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySumSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; mySubSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myMulSender;
                    private IDuplexTypedMessageSender&lt;CalculatorOutputData, CalculatorInputData&gt; myDivSender;
                }
            }
            </code>
            </example>
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs">
            <summary>
            Event argument containing parameters of the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.#ctor(System.String,System.String,System.String)">
            <summary>
            Constructs the event argument.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ChannelId">
            <summary>
            Returns the channel id identifying the receiver of request messages. (e.g. tcp://127.0.0.1:8090/).
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.ResponseReceiverId">
            <summary>
            Returns the unique logical id identifying the receiver of response messages.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelEventArgs.SenderAddress">
            <summary>
            Returns the address where the sender of the request message is located. (e.g. IP address of the client).
            It can be empty string if not applicable for used messaging.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.EndPoints.StringMessages.NamespaceDoc">
            <summary>
            Functionality to send and receive simple text messages.
            </summary>
            <example>
            For more details see example:
            <ul>
                <li><see cref="T:Eneter.Messaging.EndPoints.StringMessages.DuplexStringMessagesFactory"/> - sending and receiving text messages.</li>
            </ul>
            </example>
        </member>
        <member name="T:Eneter.Messaging.Diagnostic.NamespaceDoc">
            <summary>
            Functionality for tracing.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory">
            <summary>
            Implents the factory creating broker and broker client.
            </summary>
            <remarks>
            The broker is the component that provides functionality for publish-subscribe scenarios.
            IDuplexBrokerClient provides functionality to send notification messages to the broker
            and also to subscribe for desired messages.
            
            <example>
            The example shows how to create and use the broker communicating via TCP.
            <code>
            // Create Tcp based messaging.
            IMessagingSystemFactory aMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex input channel listening to messages.
            IDuplexInputChannel anInputChannel = aMessagingFactory.CreateDuplexInputChannel("tcp://127.0.0.1:7980/");
            
            // Create the factory for the broker.
            IDuplexBrokerFactory aBrokerFactory = new DuplexBrokerFactory();
            
            // Create the broker.
            IDuplexBroker aBroker = aBrokerFactory.CreateBroker();
            
            // Attach the Tcp duplex input channel to the broker and start listening.
            aBroker.AttachDuplexInputChannel(anInputChannel);
            </code>
            
            <code>
            Subscribing for the notification messages.
            
            // Create Tcp based messaging for the silverlight client.
            IMessagingSystemFactory aTcpMessagingFactory = new TcpMessagingSystemFactory();
            
            // Create duplex output channel to send and receive messages.
            myOutputChannel = aTcpMessagingFactory.CreateDuplexOutputChannel("tcp://127.0.0.1:7980/");
            
            // Create the broker client
            IDuplexBrokerFactory aDuplexBrokerFactory = new DuplexBrokerFactory();
            myBrokerClient = aDuplexBrokerFactory.CreateBrokerClient();
            
            // Handler to process notification messages.
            myBrokerClient.BrokerMessageReceived += NotifyMessageReceived;
            
            // Attach the channel to the broker client to be able to send and receive messages.
            myBrokerClient.AttachDuplexOutputChannel(myOutputChannel);
            
            // Subscribe in broker to receive chat messages.
            myBrokerClient.Subscribe("MyChatMessageType");
            
            
            ...
            
            
            // Send message to the broker. The broker will then forward it to all subscribers.
            XmlStringSerializer anXmlSerializer = new XmlStringSerializer();
            object aSerializedChatMessage = anXmlSerializer.Serialize&lt;ChatMessage&gt;(aChatMessage);
            myBrokerClient.SendMessage("MyChatMessageType", aSerializedChatMessage);
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor">
            <summary>
            Constructs the broker factory with XmlStringSerializer.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory with specified serializer.
            </summary>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(System.Boolean)">
            <summary>
            Constructs the broker factory.
            </summary>
            <remarks>
            It allows to specify if the broker client gets notification from the broker for its own published events.
            E.g. if the broker client is subscribed to the event 'StatusChanged' and if this broker client also publishes the
            event 'StatusChanged' then if the parmater publisherCanBeNotified is false the broker client will not get notification events
            from its own published events.
            </remarks>
            <param name="publisherCanBeNotified">false - broker does not send notifications to the broker client
            which published the event.
            </param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.#ctor(System.Boolean,Eneter.Messaging.DataProcessing.Serializing.ISerializer)">
            <summary>
            Constructs the broker factory.
            </summary>
            <remarks>
            It allows to specify if the broker client gets notification from the broker for its own published events.
            E.g. if the broker client is subscribed to the event 'StatusChanged' and if this broker client also publishes the
            event 'StatusChanged' then if the parmater publisherCanBeNotified is false the broker client will not get notification events
            from its own published events.
            </remarks>
            <param name="publisherCanBeNotified">false - broker does not send notifications to the broker client
            which published the event.
            </param>
            <param name="serializer">serializer used by the broker</param>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBrokerClient">
            <summary>
            Creates the broker client.
            </summary>
            <remarks>
            The broker client is able to send messages to the broker (via attached duplex output channel).
            It also can subscribe for messages to receive notifications from the broker.
            </remarks>
        </member>
        <member name="M:Eneter.Messaging.Nodes.Broker.DuplexBrokerFactory.CreateBroker">
            <summary>
            Creates the broker.
            </summary>
            <remarks>
            The broker receives messages and forwards them to subscribers.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.SynchronousMessagingSystem.NamespaceDoc">
            <summary>
            The messaging system transferring messages synchronously in the context of the caller thread.
            </summary>
            <remarks>
            This messaging system transfers messages synchronously in the context of the calling thread.
            Therefore the calling thread is blocked until the message is delivered and processed.
            However, the notification events (e.g. connection opened, ...) can come in a different thread.
            The messaging system is very fast and is suitable to deliver messages locally between internal communication components.
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs">
            <summary>
            Event argument used to notify that duplex input channel received a message.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.#ctor(System.String,System.Object,System.String,System.String)">
            <summary>
            Constructs the event.
            </summary>
            <param name="channelId">Identifies the receiver of request messages. (e.g. tcp://127.0.0.1:8090/)</param>
            <param name="message">message</param>
            <param name="responseReceiverId">Unique logical id identifying the receiver of response messages.</param>
            <param name="senderAddress">Address where the sender of the request message is located. (e.g. IP address of the client)<br/>
            Can be empty string if not applicable in used messaging.</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.MessagingSystemBase.DuplexChannelMessageEventArgs.Message">
            <summary>
            Returns the message.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter">
            <summary>
            The helper allowing to observe the particular duplex output channel.
            If the channel is disconnected, it tries to reopen the connection.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel)">
            <summary>
            Constructs the reconnecter that tries to reconnect infinitely every second.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.#ctor(Eneter.Messaging.MessagingSystems.MessagingSystemBase.IDuplexOutputChannel,System.TimeSpan,System.Int32)">
            <summary>
            Constructs the reconnecter from specified parameters.
            </summary>
            <param name="duplexOutputChannel">observed duplex output channel</param>
            <param name="reconnectFrequency">how often the reconnect attempt shall be performed (in case of the disconnection)</param>
            <param name="maxReconnectAttempts">max amounts of reconnect attempts. If exceeded, the ReconnectingFailed is invoked.</param>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.EnableReconnecting">
            <summary>
            Enables the automatic reconnecting in case the disconnect is notified.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.DisableReconnecting">
            <summary>
            Disables the automatic reconnecting.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionClosed">
            <summary>
            The event is invoked when the observed duplex output channel notified, that the connection was closed.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ConnectionOpened">
            <summary>
            The event is invoked when the duplex output channel was reconnected.
            </summary>
        </member>
        <member name="E:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.ReconnectingFailed">
            <summary>
            The event is invoked when the reopenning of the duplex output channel failed.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.Reconnecter.IsReconnectingEnabled">
            <summary>
            Returns true if the reconnecting is enabled.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType">
            <summary>
            Type of the message sent by the monitor duplex output channel or monitor dupolex input channel.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Ping">
            <summary>
            Indicates, it is the ping message or ping response.
            </summary>
        </member>
        <member name="F:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType.Message">
            <summary>
            Indicates, it is a message or a response message containing data. 
            </summary>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage">
            <summary>
            The message used by the monitor duplex output channel or monitor duplex input channel for the communication.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor">
            <summary>
            Constructs the message. This constructor is used by the Xml serializer for the deserialization.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.#ctor(Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessageType,System.Object)">
            <summary>
            Constructs the message from specified parameters.
            </summary>
            <param name="messageType">type of the message, ping or regular message</param>
            <param name="messageContent">message content, in case of ping this parameter is not used</param>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageType">
            <summary>
            Type of the message. Ping or regular message.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.MonitoredMessagingComposit.MonitorChannelMessage.MessageContent">
            <summary>
            Message. In case of the 'ping', this property is null.
            </summary>
        </member>
        <member name="T:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1">
            <summary>
            Thread processing messages from the queue.
            </summary>
            <remarks>
            It provides a working thread processing messages from the queue.
            If a message is put to the queue the working thread will remove it from the queue and will call the registered handler
            to process it.
            </remarks>
            <typeparam name="_MessageType">type of the message processed by the thread</typeparam>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.RegisterMessageHandler(System.Action{`0})">
            <summary>
            Registers the handler processing messages.
            </summary>
            <param name="messageHandler"></param>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.UnregisterMessageHandler">
            <summary>
            Unregisters the handler processing messages.
            </summary>
        </member>
        <member name="M:Eneter.Messaging.DataProcessing.MessageQueueing.WorkingThread`1.EnqueueMessage(`0)">
            <summary>
            Enqueues the message to the queue.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.NamespaceDoc">
            <summary>
            Provides the messaging system with the authentication mechanism.
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetLoginMessage">
            <summary>
            Callback delegate used to get the login message.
            </summary>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <returns>login message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHanshakeMessage">
            <summary>
            Callback delegate used to get the handshake message.
            </summary>
            <remarks>
            The handshake message is sent by a service after login is received.
            The client is supposed to send a response handshake message back to the service.
            </remarks>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message received from the client</param>
            <returns>handshake message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.GetHandshakeResponseMessage">
            <summary>
            Callback delegate used to get the response for the handshake message.
            </summary>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="handshakeMessage">handshake message received from the service</param>
            <returns>handshake response message</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticateClient">
            <summary>
            Callback method used to authenticate the client. If it returns true the client is authenticated.
            </summary>
            <param name="channelId">service address</param>
            <param name="responseReceiverId">unique id representing the connection with the client</param>
            <param name="loginMessage">login message that was sent from the client</param>
            <param name="handshakeMessage">handshake message sent from the service</param>
            <param name="handshakeResponse">handshake response received from the client</param>
            <returns>true if the client is authenticated</returns>
        </member>
        <member name="T:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory">
            <summary>
            Provides the messaging system with the authentication.
            </summary>
        </member>
        <member name="P:Eneter.Messaging.MessagingSystems.Composites.AuthenticatedConnection.AuthenticatedMessagingFactory.AuthenticationTimeout">
            <summary>
            Sets or gets the timeout for the authentication.
            </summary>
            <remarks>
            The authentication timeout is used by dulex output channel when opening connection.
            If the connection is open but the authentication exceeds defined time the timeout exception is thrown and the connection is not open.
            Default value is 10 seconds.
            </remarks>
        </member>
    </members>
</doc>
